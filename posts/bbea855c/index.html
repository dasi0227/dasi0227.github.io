<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>运输层 | Dasi's Blog</title><meta name="author" content="Dasi"><meta name="copyright" content="Dasi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多路复用、多路分解、UDP和TCP、可靠数据传输原理、流水线模式和拥塞控制算法"><meta property="og:type" content="article"><meta property="og:title" content="运输层"><meta property="og:url" content="https://dasi.net.cn/posts/bbea855c/"><meta property="og:site_name" content="Dasi&#39;s Blog"><meta property="og:description" content="多路复用、多路分解、UDP和TCP、可靠数据传输原理、流水线模式和拥塞控制算法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dasi.net.cn/image/cover_computernetwork.webp"><meta property="article:published_time" content="2024-08-22T10:10:37.000Z"><meta property="article:modified_time" content="2024-11-06T07:49:08.047Z"><meta property="article:author" content="Dasi"><meta property="article:tag" content="计网"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://dasi.net.cn/image/cover_computernetwork.webp"><link rel="shortcut icon" href="/image/avatar.webp"><link rel="canonical" href="https://dasi.net.cn/posts/bbea855c/"><link rel="preconnect"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-1sRsbKtiRS"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=6.5.1"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.33" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6230f5f166612db2398c773b5c5e2a61";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:8,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:250,languages:{author:"作者: Dasi",link:"链接: ",source:"来源: Dasi's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.11.1",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!1,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"运输层",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-11-06 15:49:08"}</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/tag.css?1"><link rel="stylesheet" href="/css/nav.css?1"><link rel="stylesheet" href="/css/homeArticle.css?1"><link rel="stylesheet" href="/css/category.css?1"><link rel="stylesheet" href="/css/cursor.css?1"><link rel="stylesheet" href="/css/background.css?1"><link rel="stylesheet" href="/css/rightmenu.css?1"><link rel="stylesheet" href="/css/copyright.css?1"><link rel="stylesheet" href="/css/archive.css?1"><link rel="stylesheet" href="/css/description.css?1"><link rel="stylesheet" href="/css/post.css?1"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",(()=>{o()}))})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/image/cover_computernetwork.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Dasi's Blog"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp"><span class="site-name">Dasi's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">运输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-22T10:10:37.000Z" title="发表于 2024-08-22 18:10:37">2024-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="运输层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h2 id="1-运输层">1. 运输层</h2><p>运输层协议的位置：<strong>网络边缘/端系统</strong></p><ul><li>发送：运输层将从发送方进程接收到报文转换为运输层分组，然后传递给网络层</li><li>接收：运输层从网络层接收到的运输层分组提取数据，然后传递给接收方进程</li></ul><div class="note info flat"><p>运输层分组严格来说又叫报文段（segment）</p></div><p>区分运输层协议和网络层协议</p><ul><li>运输层协议的功能：提供了运行在不同主机上的<strong>进程之间的逻辑通信</strong></li><li>网络层协议的功能：提供了<strong>主机之间的逻辑通信</strong></li></ul><div class="note success flat"><p>类比</p><ul><li>应用层报文 = 信件</li><li>进程 = 家庭成员</li><li>主机 = 家庭</li><li>运输层协议 = 家庭代表</li><li>网络层协议 = 邮政服务</li></ul><p>理解</p><ul><li>有两个家庭A和B，家庭成员之间需要通过信件互相通信，家庭A指派成员a作为家庭代表，家庭B指派成员b作为家庭代表，负责收集全部家庭成员的信去发送，同时将接收到的信分发给各个家庭成员，信件则通过邮政服务实现家庭到家庭之间的传递</li><li>a和b都是在各自的家庭进行工作的，并没有参与邮政服务的工作，因此运输层协议只是工作在端系统中</li><li>邮政服务提供的是家庭到家庭之间的信件传递，对应于主机间的逻辑通信；a和b提供的是A家庭成员和B家庭成员之间的信件传递，对应于进程间的逻辑通信</li></ul></div><p><strong>端到端原则（end-to-end principle）</strong>：是计算机网络设计中的一种设计哲学，强调将<strong>特殊功能和错误处理放置在网络边缘（应用层和运输层），而不是网络核心（网络层和链路层）</strong></p><ul><li><strong>简化网络设计</strong>：减少网络中间节点的复杂性，避免在网络中间引入过多的处理逻辑</li><li><strong>提升可靠性</strong>：将关键的错误检测和恢复功能放在终端设备上，使得网络的核心部分可以保持高效和简洁</li></ul><div class="note warning flat"><p>与在较高级别提供特殊功能的代价相比，在较低级别上设置特殊功能可能是冗余的，不起作用的，甚至毫无意义和价值的</p></div><h2 id="2-多路复用与多路分解">2. 多路复用与多路分解</h2><p><strong>多路分解（demultiplexing）</strong>：将报文段中的数据交付到正确的套接字（家庭代表收集每个家庭成员的信，然后一起投递到邮局）</p><p><strong>多路复用（multiplexing）</strong>：在源主机从不同套接字收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层（家庭代表从邮局取回很多信，然后分发给对应的家庭成员）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856574.png" alt=""></p><p><strong>套接字（socket）</strong>：是应用层和运输层之间的接口，是从网络向进程传递数据和从进程向网络传递数据的门户，是实现多路的必要条件，用于区分不同网络节点上运行的不同进程，其中网络节点通过ip地址来区分，进程通过端口号来区分</p><ul><li>UDP套接字：二元组<code>(目的IP,目的端口号)</code></li><li>TCP套接字：四元组<code>(源IP,源端口号,目的IP,目的端口号)</code></li></ul><h2 id="3-UDP">3. UDP</h2><h3 id="3-1-UDP性质">3.1 UDP性质</h3><p>UDP性质</p><ul><li><strong>无连接的</strong>：发送方和接收方的运输层实体之间没有握手，发送方将分组传递给网络层之后就不再关心</li><li><strong>不可靠的</strong>：提供最少的服务，除了复用/分解功能和少量的差错检测，几乎没有对IP增加别的东西，不提供数据重传或顺序保证</li></ul><p>UDP优势</p><ul><li><strong>应用层控制更加精细</strong>：UDP不干涉也不关心数据发送过程，应用层可以完全自由选择发送的数据和发送的时间</li><li><strong>无需连接建立</strong>：UDP不需要建立连接，省略了连接建立、拆除和维护的步骤，减少了通信延迟</li><li><strong>无连接状态</strong>：UDP是不可靠的，不维护连接状态，也不跟踪连接的状态信息，减少了接收方和发送方的资源消耗</li><li><strong>分组首部开销小</strong>：UDP仅有8字节首部，而TCP有20字节的首部，节省带宽</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856575.png" alt=""></p><p>UDP劣势：<strong>缺乏拥塞机制</strong></p><ul><li><strong>路由器分组溢出</strong>：当许多用户同时发送大数据量的UDP分组时，路由器和交换机可能会受到严重的负荷，造成网路性能下降和丢包</li><li><strong>挤垮TCP会话</strong>：UDP造成的网络拥塞会触发TCP的拥塞控制机制，从而大大减小TCP发送方的速率</li></ul><h3 id="3-2-UDP报文段">3.2 UDP报文段</h3><p>结构：<strong>首部4个字段，每个字段2字节</strong></p><ul><li>源端口号：标识发送进程</li><li>目的端口号：标识接收进程</li><li>长度：整个报文段长度，即首部+数据的字节数</li><li>检验和：验证数据在传输过程中是否发生了错误</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856576.png" alt=""></p><p><strong>检验和（checksum）</strong></p><ul><li>发送方<ol><li>填充与求和：将UDP报文段中所有16比特字相加，<strong>如果数据部分的长度不是16位的整数倍，则填充0</strong></li><li>回卷：如果和超过16位，则<strong>将溢出的部分重新加回</strong></li><li>反转：<strong>将最终的和按位取反</strong></li></ol></li><li>接收方<ul><li>填充、求和、回卷：与上述一样，得到所有字的和</li><li>检验：将检验和与上一步所有字的和相加，如果和是1111111111111111则表示报文段没有出差错，<strong>否则只要有一个比特是0则表示数据出错</strong></li></ul></li></ul><p>UDP检验和性质：</p><ul><li><strong>仅能够检测出差错，但是无法定位差错，也无法恢复差错</strong>，因此UDP接收方在发现差错时仅选择丢弃受损报文段</li><li>能有效检测出奇数个比特差错，但<strong>无法有效检测出偶数个比特差错</strong>（因为同一位上的不同字出现偶数个比特翻转，最后得到的所有字的和是一样的）</li></ul><h2 id="4-可靠数据传输原理">4. 可靠数据传输原理</h2><h3 id="4-1-可靠数据传输协议">4.1 可靠数据传输协议</h3><p>可靠数据传输协议（reliable data transfer protocol,rdt）：没有<strong>数据损坏和数据丢失</strong>，并且数据<strong>按发送顺序</strong>进行交付</p><div class="note warning flat"><p>可靠信道是运输层给应用层提供的抽象服务，实际上是通过较低层的不可靠信道传输，经过运输层的处理后才变得可靠</p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856577.png" alt=""></p><p>基本函数</p><table><thead><tr><th>函数名</th><th>调用者</th><th>作用</th></tr></thead><tbody><tr><td><code>rdt_send(data)</code></td><td>应用层</td><td>指示运输层发送方从应用层中获取数据</td></tr><tr><td><code>rdt_rcv(packet)</code></td><td>网络层</td><td>指示运输层接收方从网络层获取分组</td></tr><tr><td><code>make_pkt(data)</code></td><td>运输层发送方</td><td>将数据加上首部封装成分组</td></tr><tr><td><code>extract(packet, data)</code></td><td>运输层接收方</td><td>从分组中取出数据</td></tr><tr><td><code>udt_send(packet)</code></td><td>运输层发送方</td><td>将分组发送到网络层</td></tr><tr><td><code>deliver_data(data)</code></td><td>运输层接收方</td><td>将数据交付给应用层</td></tr></tbody></table><p>有限状态机（Finite-State Machine,FSM）：由<strong>状态、状态转移、事件和操作</strong>组成</p><ul><li>圆：状态</li><li>箭头：状态转移，取决于事件和操作</li><li>横线上方：引起状态转移的事件</li><li>横线下方：实现状态转移的操作</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">Λ</span></span></span></span>：空，表示没有事件或没有操作</li></ul><h3 id="4-2-rdt1-0">4.2 rdt1.0</h3><p>rdt1.0：<strong>底层信道是完全可靠，不需要进行差错检测和修复</strong></p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>发送端等待调用</td><td>应用层调用</td><td>封装分组并发送</td><td>转移到自身</td></tr><tr><td>接收端等待调用</td><td>网络层调用</td><td>提取数据，交付应用层</td><td>转移到自身</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856578.png" alt=""></p><h3 id="4-3-rdt2-x">4.3 rdt2.x</h3><h4 id="4-3-1-rdt-2-0">4.3.1 rdt.2.0</h4><p><strong>自动重传协议（Automatic Repeat reQuest,ARQ）</strong></p><ul><li>检测：发送方会将检测字段封装进分组中，接收方会根据检测字段进行差错检测</li><li>反馈：<strong>肯定确认（positive acknowledgement,ACK）</strong>，<strong>否定确认（negative acknowledgement,NCK）</strong>，接收方需要向发送方发送ACK分组或NCK分组</li><li>重传：接收方接收到NCK分组后，需要重传该分组</li></ul><p><strong>停等协议（stop-and-wait）</strong>：发送方不会发送新分组，直到发送方收到来自接收方的肯定确认</p><p>rdt2.0：实现了差错检测，接收方通过ACK和NAK告知发送方分组情况</p><table><thead><tr><th>函数名</th><th>调用者</th><th>作用</th></tr></thead><tbody><tr><td><code>isNAK(rcvpkt)和isACK(rcvpkt)</code></td><td>运输层发送方</td><td>判断发送的分组是否被正确接收</td></tr><tr><td><code>notcorrupt(rcvpkt)和corrupt(rcvpkt)</code></td><td>运输层接收方</td><td>判断接收的分组是否有差错</td></tr></tbody></table><p>发送端</p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>等待调用</td><td>应用层调用</td><td>封装分组并发送</td><td>转移到“等待确认”</td></tr><tr><td>等待确认</td><td>接收ACK</td><td>不执行任何操作</td><td>转移到“等待调用”</td></tr><tr><td>等待确认</td><td>接收NAK</td><td>重传分组</td><td>转移到自身</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856579.png" alt=""></p><p>接收端</p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>等待调用</td><td>分组没有差错</td><td>提取数据，交付应用层，发送ACK</td><td>转移到自身</td></tr><tr><td>等待调用</td><td>分组出现差错</td><td>发送NAK</td><td>转移到自身</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856580.png" alt=""></p><h4 id="4-3-1-rdt-2-1">4.3.1 rdt.2.1</h4><p>rdt2.0的局限性：没有考虑到ACK或NAK分组受损的可能性</p><p>不合适的处理方案</p><table><thead><tr><th>方案</th><th>情况</th><th>结果</th></tr></thead><tbody><tr><td>发送方利用新分组询问接收方</td><td>新分组也有可能差错</td><td><strong>无限循环确认</strong></td></tr><tr><td>发送方可以修复差错</td><td>需要增加足够的检验和比特</td><td><strong>首部过大</strong></td></tr><tr><td>发送方重传分组</td><td>可能在ACK的情况下依旧重传</td><td><strong>冗余分组</strong></td></tr></tbody></table><p>rdt2.1：让发送方对分组进行编号，将序号封装在首部字段，接收方仅需要根据序号就可以判断当前分组是否是冗余分组</p><table><thead><tr><th>函数名</th><th>调用者</th><th>作用</th></tr></thead><tbody><tr><td><code>has_seq1(rcvpkt)和has_seq0(rcvpkt)</code></td><td>运输层接收方</td><td>确认当前分组的序号</td></tr><tr><td><code>notcorrupt(rcvpkt)和corrupt(rcvpkt)</code></td><td>运输层接收方和运输层发送方</td><td>判断接收的分组是否有差错</td></tr></tbody></table><p>发送端</p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>0号等待调用</td><td>应用层调用</td><td>封装0号分组并发送</td><td>转移到“0号等待确认”</td></tr><tr><td>0号等待确认</td><td>接收NAK或者分组出现出错</td><td>重传0号分组</td><td>转移到自身</td></tr><tr><td>0号等待确认</td><td>接收ACK并且分组没有出错</td><td>不执行任何操作</td><td>转移到“1号等待调用”</td></tr><tr><td>1号等待调用</td><td>应用层调用</td><td>封装1号分组并发送</td><td>转移到“1号等待确认”</td></tr><tr><td>1号等待确认</td><td>接收NAK或者分组出现出错</td><td>重传1号分组</td><td>转移到自身</td></tr><tr><td>1号等待确认</td><td>接收ACK并且分组没有出错</td><td>不执行任何操作</td><td>转移到“0号等待调用”</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856581.png" alt=""></p><p>接收端</p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>0号等待调用</td><td>分组出现差错</td><td>发送NAK</td><td>转移到自身</td></tr><tr><td>0号等待调用</td><td>分组没有差错但是收到1号分组</td><td>发送ACK</td><td>转移到自身</td></tr><tr><td>0号等待调用</td><td>分组没有差错并且收到0号分组</td><td>提取数据，交付应用层，发送ACK</td><td>转移到“1号等待调用”</td></tr><tr><td>1号等待调用</td><td>分组出现差错</td><td>发送NAK</td><td>转移到自身</td></tr><tr><td>1号等待调用</td><td>分组没有差错但是收到0号分组</td><td>发送ACK</td><td>转移到自身</td></tr><tr><td>1号等待调用</td><td>分组没有差错并且收到1号分组</td><td>提取数据，交付应用层，发送ACK</td><td>转移到“0号等待调用”</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856582.png" alt=""></p><h4 id="4-3-2-rdt2-2">4.3.2 rdt2.2</h4><p>rdt2.2：与rdt2.1的唯一差别在于ACK和NAK也封装了序号</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856583.png" alt=""></p><h3 id="4-4-rdt3-0">4.4 rdt3.0</h3><p>rdt2.x的局部性：如果分组丢失，那么发送方和接收方都无法做出响应来处理</p><p>rdt3.0：采用基于时间的重传机制</p><ul><li>重传：从发送方的观点来看，只要能处理好冗余分组，<strong>重传是一种万能的方案</strong></li><li>基于时间：依靠<strong>倒计时定时器（countdown timer）</strong><ul><li><strong>启动</strong>：每次发送一个分组都需要启动倒计时定时器</li><li><strong>中断</strong>：如果在指定时间量内没有得到肯定确认中断倒计时定时器，并重传分组</li><li><strong>重置</strong>：如果在指定时间量内得到肯定确认，重置倒计时定时器</li></ul></li></ul><p>发送端</p><table><thead><tr><th>状态</th><th>事件</th><th>操作</th><th>状态转移</th></tr></thead><tbody><tr><td>0号等待调用</td><td>应用层调用</td><td>封装0号分组并发送，启动定时器</td><td>转移到“0号等待确认”</td></tr><tr><td>0号等待确认</td><td>接收1号ACK或者分组出现出错</td><td>不执行任何操作</td><td>转移到自身</td></tr><tr><td>0号等待确认</td><td>超时</td><td>重传0号分组，启动定时器</td><td>转移到自身</td></tr><tr><td>0号等待确认</td><td>接收0号ACK并且分组没有出错</td><td>中断计时器</td><td>转移到“1号等待调用”</td></tr><tr><td>1号等待调用</td><td>应用层调用</td><td>封装1号分组并发送，启动定时器</td><td>转移到“1号等待确认”</td></tr><tr><td>1号等待确认</td><td>接收0号ACK或者分组出现出错</td><td>不执行任何操作</td><td>转移到自身</td></tr><tr><td>1号等待确认</td><td>超时</td><td>重传1号分组，启动定时器</td><td>转移到自身</td></tr><tr><td>1号等待确认</td><td>接收1号ACK并且分组没有出错</td><td>中断计时器</td><td>转移到“0号等待调用”</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856584.png" alt=""></p><p><strong>比特交替协议（alternating-bit）</strong>：分组序号在0和1之间交替</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856585.png" alt=""></p><h2 id="5-流水线传输协议">5. 流水线传输协议</h2><h3 id="5-1-流水线技术">5.1 流水线技术</h3><p><strong>rdt3.0/一对一确认/停等协议的局限性：吞吐量非常低！</strong></p><div class="note success flat"><p>假设可用吞吐量R=1Gbps，RTT=30ms，分组长L=8000bits，忽略ACK的发送时延<br>发送方相邻两个分组的发送间隔是RTT+L/R=30.008ms<br>实际吞吐量为8000bits/30.008ms≈267kbps<br>宽带利用率只有可怜的267kbps/1Gbps=0.0267%（这还是在分组没有任何差错，不考虑协议处理时间，路由器的排队时延的情况下）</p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856535.png" alt=""></p><p>流水线技术（pipelining）：<strong>允许发送方在一定限度内发送多个分组而无需等待每个分组来自接收方的ACK</strong></p><ul><li>需要增加序号范围：跟踪多个分组，<strong>每个分组具有唯一序号</strong></li><li>需要添加缓存：<strong>发送方需要缓存尚未确认的分组以便重传，接收方也需要缓存尚未排序分组以便按顺序交付</strong></li><li>需要保证可靠：<strong>回退N步协议</strong>和<strong>选择重传协议</strong></li></ul><h3 id="5-2-回退N步">5.2 回退N步</h3><p><strong>回退N步协议（Go-Back-N,GBN）</strong>：允许发送方发送多个分组而不需要等待确认，但流水线中未确认分组数量不能超过最大允许数N</p><ul><li><strong>发送方基序号（base）：最小未确认的分组序号</strong></li><li><strong>下一个序号（nextseqnum）：最小未发送的分组序号</strong></li><li><strong>窗口长度（window size）：发送缓冲区大小</strong></li><li><strong>接收方期望序号（expectedseqnum）：接收方期望收到的分组序号</strong></li></ul><div class="note warning flat"><p>注意如果超过了最大序号，需要进行取模运算</p></div><p>序号范围</p><ul><li>[0,base-1]：已经发送且已经被确认的分组</li><li>[base,nextseqnum-1]：已经发送但还没有被确认的分组</li><li>[nextseqnum,base+N-1]：还没有发送但即将发送的分组</li><li>[base+N,…]：从未进入过发送方缓冲区的分组</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856536.png" alt=""></p><p>GBN实现手段</p><ul><li><strong>窗口判断</strong>：发送方通过<code>if(nextseqnum&lt;base+N)</code>判断窗口是否已满</li><li><strong>累积确认（cumulative acknowledgement）</strong>：接收方不会发送NAK只会发送ACK，表示已经正确接收到包裹expecedseqnum在内的之前的所有分组</li><li><strong>超时记录</strong>：发送方只使用一个定时器，用来记录<strong>最早的已发送但还未被确认</strong>的分组</li><li><strong>失序丢弃</strong>：接收方会丢弃一个正确接收但失序的分组，而不会缓存它</li></ul><div class="note success flat"><p>失序丢弃的可解释性：接收方在期望接收到n的时候接收到了n+1，哪怕接收方缓存了n+1，但是发送方也不知情，因此发送方依旧会在传送n之后再次传送n+1。因此接收方缓存n+1就没有任何意义了</p></div><p><strong>GBN的本质（重点）</strong></p><ul><li>发送方<ul><li><strong>不处理损坏的ACK</strong></li><li><strong>一直递增nextseqnum直到窗口已满</strong></li><li><strong>一直发送nextseqnum直到超时才回退到base进行发送</strong></li><li><strong>base只在接收到正确的ACK才递增</strong></li></ul></li><li>接收方<ul><li><strong>不会发送NAK</strong></li><li><strong>一直发送封装了最新正确分组序号的ACK</strong></li><li><strong>expectedseqnum只在接受到期望序号的分组才递增</strong></li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856537.png" alt=""></p><p>发送端：</p><table><thead><tr><th>事件</th><th>操作</th></tr></thead><tbody><tr><td>应用层调用</td><td>判断窗口是否已满</td></tr><tr><td>定时器超时</td><td>重启定时器，并回退发送序号[base,nextseqnum-1]的分组</td></tr><tr><td>接收到损坏的ACK</td><td>什么都不做</td></tr><tr><td>接收到正确的ACK</td><td>更新base为ACK中的序号+1，如果没有需要发送的分组则中断定时器，否则重启定时器</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856539.png" alt=""></p><p>接收端：</p><table><thead><tr><th>事件</th><th>操作</th></tr></thead><tbody><tr><td>收到的分组没有错误且是期望序号</td><td>提取数据，交付应用层，封装并发送ACK，递增expectedseqnum</td></tr><tr><td>收到的分组有错误或乱序</td><td>丢弃分组，封装并发送上一个ACK分组</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856540.png" alt=""></p><h3 id="5-3-选择重传">5.3 选择重传</h3><p>GBN协议的局限性：发送方必须<strong>从出错的分组开始重新发送所有后续分组</strong>，这可能导致大量无用数据的重传，特别是在高丢包率的网络中，带宽利用率会降低</p><p><strong>选择重传协议（Selective Repeat,SR）</strong>：发送方仅重传那些它认为在接收方出错的分组，接收方接收并缓存所有正确的分组</p><ul><li>发送方需要标记发送窗口中哪些分组已经被确认</li><li>接收方需要标记接收窗口中哪些分组已经被缓存</li></ul><p>接收窗口</p><ul><li>[0,rcv_base-1]：已经交付的分组</li><li>[rcv_base,buffer_start-1]：期望但还未收到的分组</li><li>[buffer_start,buffer_end]：失序且被缓存的分组</li><li>[buffer_end+1,rcv_base+N-1]：可以接收的分组</li><li>[rcv_base+N,…]：无法进入接受窗口的分组</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856541.png" alt=""></p><p>基序号的变化</p><ul><li>发送窗口<ul><li>若发送窗口的基序号分组被确认且窗口内存在尚未被确认的分组，则<strong>基序号需要更新为窗口中最近未被确认的分组序号</strong></li><li>若发送窗口的基序号分组被确认且窗口内全部分组都被确认，则<strong>基序号需要向后移动N个位置</strong></li></ul></li><li>接收窗口<ul><li>若接收窗口的基序号分组正确接收且窗口内存在尚未收到的分组，则<strong>基序号需要更新为窗口中最近未收到的分组序号</strong></li><li>若发送窗口的基序号分组被确认且窗口内全部分组都收到，则<strong>基序号需要向后移动N个位置</strong></li></ul></li></ul><p>窗口尺寸问题</p><ul><li>发送窗口尺寸过小<ul><li>可发送的分组太少了，导致<strong>带宽利用率低</strong></li><li>窗口很快就满了，发送方不得不等待接收方的确认，导致<strong>时延变长</strong></li></ul></li><li>接收窗口尺寸过大<ul><li>缓存大量大量乱序分组，需要<strong>消耗更多内存</strong></li><li>如果序号空间不足，可能会导致<strong>序号重叠</strong>的问题</li></ul></li></ul><p>序号重叠：<strong>无法区分刚到的分组是重传还是新分组</strong>，因此<strong>接收窗口的长度应该小于或等于序号长度的一半</strong></p><div class="note warning flat"><p>对于下图，发送方视角是不一样的，但是接收方视角是一模一样的</p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856542.png" alt=""></p><h2 id="6-TCP">6. TCP</h2><h3 id="6-1-TCP性质">6.1 TCP性质</h3><ol><li><strong>面向连接的（connection-oriented）</strong>：在发送数据之前，通信的两端需要建立一个连接，实际上这种连接是逻辑上的，不依赖于物理连接</li><li><strong>全双工服务（full-duplex service）</strong>：允许通信的两端同时进行数据发送和接收</li><li><strong>点对点（point-to-point）</strong>：每个连接由两个唯一的IP地址和端口号组成，不存在第三个对等的角色</li><li><strong>最大报文段长度（Maximum Segment Size,MSS）</strong>：定义了单个TCP报文段的最大数据负载大小（不包括TCP头部）</li><li><strong>缓存（Buffer）</strong>：通过设置发送缓存和接收缓存来实现可靠的数据传输和流量控制</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856543.png" alt=""></p><h3 id="6-2-TCP报文段结构">6.2 TCP报文段结构</h3><table><thead><tr><th>字段</th><th>长度/bit</th><th>作用</th></tr></thead><tbody><tr><td>源端口号（Resource Port）</td><td>16</td><td>标识数据传输的起始端点</td></tr><tr><td>目的端口号（Destination Port）</td><td>16</td><td>标识数据传输的终止端点</td></tr><tr><td>序号（Sequence Number）</td><td>32</td><td>标识TCP数据流中的字节顺序</td></tr><tr><td>确认号（Acknowledgement Number）</td><td>32</td><td>标识下一个期望接收的字节序号</td></tr><tr><td>首部长度（Header Length）</td><td>4</td><td>指示TCP头部长度，以32位字为单位</td></tr><tr><td>保留区域（Reserved）</td><td>3</td><td>保留，可能会在未来的协议扩展中有新的用途</td></tr><tr><td>减少拥塞窗口（CWR）</td><td>1</td><td>发送方用于确认它已经响应了网络拥塞，调整了其拥塞窗口</td></tr><tr><td>显式拥塞通知（ECN-Echo）</td><td>1</td><td>接收方用于通知发送方网络发生了拥塞</td></tr><tr><td>标志（Flags）</td><td>6</td><td>控制位，标识特殊功能（具体在下面）</td></tr><tr><td>接收窗口（Window）</td><td>16</td><td>指定接收方的缓存区域大小</td></tr><tr><td>检验和（Checksum）</td><td>16</td><td>检验报文在传输过程中是否出错</td></tr><tr><td>紧急数据指针（Urgent Pointer）</td><td>16</td><td>指示紧急数据在数据流中的位置</td></tr><tr><td>选项（Options）</td><td>可变</td><td>用于传输协议的扩展功能</td></tr><tr><td>数据（Data）</td><td>可变</td><td>实际传输的应用数据部分</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856544.png" alt=""></p><p>序号和确认号</p><ul><li>序号：TCP把数据看作是无结构的、有顺序的字节流，因此<strong>报文段的序号是该报文段首字节的字节流编号</strong></li><li>确认号：TCP是全双工的，因此客户接收到服务器的报文段也是有序号的，<strong>确认号就是当前主机期望接收到的下一个字节的序号</strong>，即确认报文的序号</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856545.png" alt=""></p><div class="note warning flat"><p>如图，考虑以下情况，主机A是客户，主机B是服务器。主机A键入的每个字符会显示在主机B上，如果主机B确实显示了，则会“回显”（echo back）到主机A上。主要经历以下三步：</p><ol><li>主机A先发送一个TCP报文x，序号42，确认号79，数据C</li><li>主机B返回一个TCP报文y，序号79，确认号43，数据C</li><li>主机A再返回一个TCP报文z，序号43，确认号80，无数据</li></ol><p>综上，可以得出几个事实：</p><ul><li>x的确认号就是y的序号！y的确认号就是z的序号！</li><li>服务器关于客户的确认被“捎带”（piggybacked）在y中</li><li>即使z没有数据，但由于遵循TCP协议，还是需要一个序号</li><li>z的确认号是80，因为客户已经接收到字节流序号为79之前的数据，所以接下来期望接收到序号为80的数据</li><li>两端的起始序号可以是随机的，没有特殊关系</li></ul></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856546.png" alt=""></p><p>标志（按顺序）</p><ul><li><strong>URG（Urgent）</strong>：紧急指示标志，表示有紧急数据需要优先处理</li><li><strong>ACK（Acknowledgement）</strong>：确认标志，用于确认收到的数据</li><li><strong>PSH（Push）</strong>：推送标志，表示接收方应尽快将数据推送到应用程序，而不是等待缓冲区满</li><li><strong>RST（Reset）</strong>：重置标志，用于重新初始化连接</li><li><strong>SYN（Synchronize）</strong>：同步标志，用于连接的建立阶段</li><li><strong>FIN（Finish）</strong>：结束标志，用于连接的终止阶段</li></ul><h3 id="6-3-RTT和超时">6.3 RTT和超时</h3><p><strong>采样往返时间（SampleRTT</strong>）：从某报文段被发出到对该报文段的确认被收到之间的时间量</p><p><strong>均值往返时间（EstimatedRTT）</strong>：由于路由器的拥塞和端系统负载的变化，SampleRTT会随之波动，因此需要对SampleRTT取平均，其中α通常取0.125</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo>⋅</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1-\alpha) \cdot EstimatedRTT + \alpha \cdot SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.4445em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:.01968em">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span></span></span></span></span></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856547.png" alt=""></p><p><strong>偏差往返时间（DevRTT）</strong>：估算SampleRTT偏离EstimatedRTT的程序，即SampleRTT的波动程度，通常取β为0.25</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>⋅</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">DevRTT = (1-\beta) \cdot DevRTT + \beta \cdot |SampleRTT-EstimatedRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:.01968em">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mord">∣</span></span></span></span></span></p><p><strong>超时间隔（TimeoutInterval）</strong>：太小导致不必要的重传，太大导致时延变大，因此超时间隔应该是期望RTT加上一定余量，且SampleRTT波动越大，余量越大</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mn>4</mn><mo>⋅</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">TimeoutInterval = EstimatedRTT + 4 \cdot DevRTTsss</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">im</span><span class="mord mathnormal">eo</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">er</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.13889em">RTT</span><span class="mord mathnormal">sss</span></span></span></span></span></p><h3 id="6-4-差错控制">6.4 差错控制</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856548.png" alt=""></p><h4 id="6-4-1-TCP发送方">6.4.1 TCP发送方</h4><table><thead><tr><th>事件</th><th>应用层调用</th><th>定时器超时</th><th>收到ACK</th></tr></thead><tbody><tr><td>发送</td><td>发送具有序号nextseqnum的报文段</td><td>发送具有最小未被确认的报文段</td><td>无</td></tr><tr><td>定时器</td><td>如果没有定时器就启动定时器</td><td>重启定时器</td><td>如果存在还未确认确认的报文段，则重启定时器</td></tr><tr><td>序号</td><td>更新nextseqnum=nextseqnum+length(data)</td><td>无</td><td>更新send_base=y</td></tr></tbody></table><h4 id="6-4-2-累计确认">6.4.2 累计确认</h4><ol><li>接收方成功接收到了seq=92，8字节数据，因此更新确认号，即发送ack=100，但是这个报文段丢失了</li><li>接收方又成功接收到了seq=100，20字节数据，因此更新确认号，即发送ack=120，这个报文段在seq=92报文段的定时器到时之前到达</li><li>发送方虽然没有收到ack=100，但是收到了ack=120，因此发送方可以确定接收方已经接收到了120之前的所有数据（否则ack不可能是120！）</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856552.png" alt=""></p><h4 id="6-4-3-超时间隔加倍">6.4.3 超时间隔加倍</h4><p><strong>超时间隔加倍</strong>：每次TCP重传时都会将下一次的超时间隔设置为先前的两倍，而不是利用公式计算</p><ul><li>优点：缓解可能的网络拥塞</li><li>缺点：增加端到端时延</li></ul><h4 id="6-4-4-快速重传">6.4.4 快速重传</h4><p>TCP接收方发送ACK的情况</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856553.png" alt=""></p><p><strong>快速重传（fast retransmit）</strong>：如果TCP发送方接收到<strong>3个冗余ACK</strong>，则可以认为该ACK所期望的报文段已经丢失，发送方就会立即重传该报文段，而不会呆版地等待定时器到时</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856554.png" alt=""></p><h3 id="6-5-流量控制">6.5 流量控制</h3><p><strong>接收窗口（receive windo,rwnd）</strong>：是<strong>发送方维护</strong>的一个变量，用于指示接收方的接收缓存还有多少可用空间</p><p>流量控制：消除发送方发送过多分组导致的接收方缓存溢出</p><ul><li>RcvBuffer：接收缓存的大小</li><li>LastByteRead：从接收缓存交付的最后一个字节的编号</li><li>LastByteRcvd：从网络中得到的最后一个字节的编号</li><li>LastByteSent：从发送缓存发送的的最后一个字节的编号</li><li>LastByteAcked：得到确认的最后一个字节的编号</li><li>rwnd：接收窗口</li></ul><p>满足以下公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>R</mi><mi>c</mi><mi>v</mi><mi>d</mi><mo>−</mo><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>R</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo>≤</mo><mi>R</mi><mi>c</mi><mi>v</mi><mi>B</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>R</mi><mi>c</mi><mi>v</mi><mi>B</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>−</mo><mo stretchy="false">(</mo><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>R</mi><mi>c</mi><mi>v</mi><mi>d</mi><mo>−</mo><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>R</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>−</mo><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>A</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>d</mi><mo>≤</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">LastByteRcvd-LastByteRead \leq RcvBuffer\\ \,\\ rwnd = RcvBuffer - (LastByteRcvd-LastByteRead)\\ \,\\ LastByteSent-LastByteAcked \leq rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.10764em">ff</span><span class="mord mathnormal" style="margin-right:.02778em">er</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0"></span><span class="mspace" style="margin-right:.1667em"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.10764em">ff</span><span class="mord mathnormal" style="margin-right:.02778em">er</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0"></span><span class="mspace" style="margin-right:.1667em"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">A</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span></span></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856555.png" alt=""></p><h3 id="6-6-连接控制">6.6 连接控制</h3><h4 id="6-6-1-建立连接：三次握手">6.6.1 建立连接：三次握手</h4><p>三次握手流程</p><ol><li>客户端TCP向服务器端TCP发送SYN报文段</li></ol><ul><li>首部中的SYN标志位被置为1，ACK标志位被置为0</li><li>客户会随机地选择一个初始序号（client_isn）</li><li>确认号字段被置为0</li></ul><ol start="2"><li>服务器端TCP接收到SYN报文段，为TCP连接分配缓存和变量，并向客户端TCP发送SYNACK报文段</li></ol><ul><li>首部中的SYN标志位被置为1，ACK标志位被置为1</li><li>服务器会随机选一个初始序号（server_isn）</li><li>确认号字段被置为client_isn+1</li></ul><ol start="3"><li>客户端TCP接收到SYNACK报文段，为TCP连接分配缓存和变量，并向服务器端TCP发送ACK报文段</li></ol><ul><li>首部中的SYN标志位被置为0，ACK标志位被置为1</li><li>序号字段被置为client_isn+1</li><li>确认号字段被置为server_isn+1</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856556.png" alt=""></p><p>为什么需要三次握手</p><ul><li>全双工通信<ul><li>第一次握手<strong>确认客户端请求建立连接</strong></li><li>第二次握手<strong>确认服务器同意建立连接</strong>，并且<strong>服务器可以接收到客户数据</strong></li><li>第三次握手<strong>确认客户可以接收到服务器的数据</strong></li></ul></li><li>可靠性：三次握手确保双方都能正确接收和处理对方的序列号和确认号，从而实现可靠数据传输</li></ul><p>SYN洪泛攻击：一种常见的DOS攻击，目标是耗尽服务器的资源，从而使其无法处理合法请求</p><ul><li>过程：攻击者发送大量的TCP SYN报文段但不完成第三次握手，造成服务器不断为这些半开连接分配资源但从不使用，导致服务器的连接资源被消耗殆尽</li><li>解决：服务器响应时，生成并回送一个包含了客户端的请求信息和服务器的状态的SYN cookie，而不是直接在内存中保存半开连接的状态；之后服务器收到ACK时，通过解密和验证SYN cookie，确定是否需要建立连接</li></ul><h4 id="6-6-2-结束连接：四次挥手">6.6.2 结束连接：四次挥手</h4><p>四次握手流程（假设客户主动结束连接）</p><ol><li>客户会向服务器发送一个FIN报文段，首部的FIN标志位被置为1</li><li>服务器收到FIN报文段之后，回送一个ACK报文段</li><li>服务器会向客户发送一个FIN报文段，首部的FIN标志位被置为1</li><li>客户收到FIN报文段之后，回送一个ACK报文段</li></ol><div class="note warning flat"><p>TCP连接的双方都可以终止连接，当连接结束时，主机的资源（缓存和变量）都会被释放</p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856557.png" alt=""></p><p>客户TCP状态变迁</p><ol><li><strong>CLOSED → SYN_SENT</strong>：客户端从关闭状态转变为发送SYN报文请求建立连接的状态。</li><li><strong>SYN_SENT → ESTABLISHED</strong>：客户端在接收到服务器的SYN-ACK响应后，发送ACK，连接状态变为ESTABLISHED，表示连接成功建立。</li><li><strong>ESTABLISHED → FIN_WAIT_1</strong>：在连接中，客户端发送FIN报文段请求关闭连接，状态变为FIN_WAIT_1。</li><li><strong>FIN_WAIT_1 → FIN_WAIT_2</strong>：客户端收到服务器对FIN的ACK响应后，状态变为FIN_WAIT_2，表示服务器也已准备好关闭连接。</li><li><strong>FIN_WAIT_2 → TIME_WAIT</strong>：客户端收到服务器发送的FIN报文段，回送ACK后，状态变为TIME_WAIT，等待可能的重传</li><li><strong>TIME_WAIT → CLOSED</strong>：在TIME_WAIT状态下，客户端等待预设的时长后，连接完全关闭，状态变为CLOSED。</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856558.png" alt=""></p><h4 id="6-6-3-终止连接">6.6.3 终止连接</h4><p>RST报文段：首部的RST标志位设置为1，用于立即终止一个异常的TCP连接</p><div class="note warning flat"><p>虽然是英文是reset，但不是重新建立一个连接，而是强行终止一个连接</p></div><p>适用情况</p><ul><li><strong>异常连接</strong>：服务器接收到一个无效的或不期望的报文，例如客户端试图访问一个没有在服务器上监听的端口，或者在连接过程中发送了错误格式的报文</li><li><strong>拒绝连接</strong>：服务器收到非法的连接请求，例如客户的连接请求未被授权，该端口不允许被访问，或需要额外的安全检查</li><li><strong>重置连接</strong>：一个已经建立的连接变得无效或异常，例如由于网络故障或应用程序错误，连接需要被强制关闭</li></ul><h2 id="7-拥塞控制">7. 拥塞控制</h2><h3 id="7-1-拥塞原因与代价">7.1 拥塞原因与代价</h3><h4 id="7-1-1-无限大缓存的单跳路由">7.1.1 无限大缓存的单跳路由</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856559.png" alt=""></p><p>原因：吞吐量受两条连接之间的共享链路容量限制</p><p>代价：当分组的到达速率接近链路容量时，分组会经历巨大的排队时延</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856560.png" alt=""></p><ul><li>a：理想情况，分组在路由器没有排队</li><li>b：考虑排队时延</li></ul><h4 id="7-1-2-有限大缓存的单跳路由">7.1.2 有限大缓存的单跳路由</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856561.png" alt=""></p><p>供给载荷λ’（offered load）：运输层发送的报文段既有初始数据又有重传数据</p><p>原因：有限缓存溢出导致分组丢失，发送方需要重传分组</p><p>代价：发送方必要的重传以补偿因为缓存溢出而丢弃的分组消耗链路带宽；发送方不必要的重传引起路由器转发不必要的分组副本浪费链路带宽</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856562.png" alt=""></p><ul><li>a：理想情况，发送方完全知道路由器缓存是否空闲，不会发生重传</li><li>b：理想情况，当且仅当发送方确认一定发生分组丢失才重传</li><li>c：发送方只要认为可能发生分组丢失就重传</li></ul><h4 id="7-1-3-有限大缓存的多跳路由">7.1.3 有限大缓存的多跳路由</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856563.png" alt=""></p><p>原因：多路流量为有限缓存空间而竞争</p><p>代价：上游路由器转发该分组但下游路由器丢弃该分组而浪费的传输容量</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856564.png" alt=""></p><ul><li>其他路由器重载会导致当前路由器吞吐量为0</li></ul><h3 id="7-2-TCP拥塞控制">7.2 TCP拥塞控制</h3><h4 id="7-2-1-原理">7.2.1 原理</h4><p><strong>拥塞窗口（congestion window,cwnd）</strong>：是<strong>发送方维护</strong>的一个变量，用于指示不会引起网络拥塞的可发送数据量</p><ul><li>发送速率满足：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>−</mo><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>A</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>d</mi><mo>≤</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">LastByteSent-LastByteAcked \leq min\{cwnd,rwnd\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:.05017em">tB</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">A</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">min</span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">}</span></span></span></span></li><li>假设接收窗口足够大，则<strong>发送速率=cwnd/RTT</strong>，通过调整窗口大小就可以控制发送速率</li></ul><p>丢包事件：是<strong>判断拥塞的依据</strong>，虽然不一定是真的丢包了，但是发送方为了可靠数据传输需要按照丢包来处理</p><ul><li><strong>定时器超时</strong></li><li><strong>收到3个冗余ACK</strong></li></ul><p>指导性原则</p><ul><li><strong>何时减速</strong>：一个丢失的报文段意味着拥塞，应当降低TCP发送方的速率</li><li><strong>何时加速</strong>：当先前报文段的确认报文正确到达时，应当增加TCP发送方的速率</li><li><strong>如何变速</strong>：发送方不断执行<strong>带宽探测</strong>，并根据探测结果调整数据发送速率，自适应网络的实际条件</li></ul><p>TCP吞吐量的宏观描述</p><ul><li><strong>加性增、乘性减（Additive-Increase,Multiplicative-Decrease,AIMD）方式</strong>：发送速率增大是通过逐渐增加一个MSS，发送速率减小是通过逐渐减半，引发了“锯齿”行为</li><li>假设最大窗口长度是W，则窗口长度一直在W和W/2之间变化，则平均吞吐量=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>0.75</mn><mo>×</mo><mi>W</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{0.75 \times W}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8723em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">RTT</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.75</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:.13889em">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856565.png" alt=""></p><h4 id="7-2-2-阶段">7.2.2 阶段</h4><ol><li><strong>慢启动（slow-start）</strong>：设置cwnd的初始值是1个MSS，每次收到ACK，将<strong>cwnd就翻一倍</strong></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856566.png" alt=""></p><ol start="2"><li><strong>慢启动阈值（slow-start threshold,ssthresh）</strong>：当第一次检测到拥塞时，发送方记录一个变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">ssthresh=cwnd/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord">/2</span></span></span></span>，进入拥塞避免阶段</li></ol><div class="note success flat"><p>缩小因子是1/2是为了找到cwnd/2～cwnd之间最优的拥塞窗口大小</p></div><ol start="3"><li><strong>拥塞避免（congestion avoidance）</strong>：每次收到ACK，将<strong>cwnd增加一个MSS</strong>，如果遇到定时器超时，则回归慢启动，如果收到冗余ACK，则进入快速恢复复</li></ol><div class="note success flat"><p>既然能够收到冗余ACK，则说明不是因为网络拥塞，而是因为某个分组丢失，因此不需要回到慢启动</p></div><ol start="4"><li><strong>快速恢复（fast recovery）</strong>：令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">ssthresh = cwnd / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord">/2</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>+</mo><mn>3</mn><mo>×</mo><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh + 3 \times MSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">MSS</span></span></span></span>，然后回归拥塞避免</li></ol><div class="note success flat"><p>如果不是网络拥塞导致的丢包，说明此时路由器<strong>理应具备多传输3个负载数据的报文的能力，但是却拿来传输冗余ACK了</strong>，所以应该加上3个MSS保持网络传输的高效</p></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301914132.png" alt=""></p><h4 id="7-2-3-算法">7.2.3 算法</h4><table><thead><tr><th>特性</th><th>Tahoe</th><th>Reno</th><th>CUBIC</th></tr></thead><tbody><tr><td>慢启动</td><td>指数增长</td><td>指数增长</td><td>立方型增长</td></tr><tr><td>拥塞避免</td><td>线性增长</td><td>线性增长</td><td>立方型增长</td></tr><tr><td>错误恢复</td><td>慢启动</td><td>超时：慢启动；丢包：快速恢复</td><td>立方型减缓恢复</td></tr><tr><td>适用场景</td><td>一般网络</td><td>一般网络</td><td>高带宽、长延迟网络</td></tr><tr><td>恢复速度</td><td>慢</td><td>较快</td><td>平滑且高效</td></tr></tbody></table><p>立方规则：可以快速找到新的平衡点</p><ul><li>W~max~：检测到拥塞时的cwnd值</li><li>K：预计再次到达W~max~的时间点</li><li>CUBIC：根据当前时间t和K之间的距离的立方为函数来增加cwnd</li><li>t＜K：当t远离K的时候想要快速恢复，cwnd增长较快；当t接近K的时候变得谨慎，cwnd增长较慢</li><li>t＞K：拥塞状况已经改变，t接近K的时候变的谨慎，cwnd增长较慢；当t远离k的时候想要快速找到新的平衡点，cwnd增长较快</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856567.png" alt=""></p><h3 id="7-3-其它拥塞控制">7.3 其它拥塞控制</h3><h4 id="7-3-1-ECN">7.3.1 ECN</h4><p><strong>明确拥塞通告（Explicit Congestion Notification,ECN）</strong>：路由器通过在分组头部标记ECN标志位，通知当前路由器存在拥塞</p><ol><li>路由器检测到拥塞并设置分组的ECN标志位</li><li>接收方在ACK报文中将ECE比特置位，告知发送方网络中有拥塞</li><li>发送方将拥塞窗口减半，以响应拥塞</li><li>发送方在随后的报文段中设置CWR比特，通知接收方它已经调整了拥塞窗口</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856569.png" alt=""></p><h4 id="7-3-2-基于时延">7.3.2 基于时延</h4><p>基于时延的拥塞控制：通过监测和响应网络延迟来调整数据传输比例，主要<strong>关注时延的变化</strong>而不是关注丢包，目的是为了<strong>保持网络管道的最佳负载状态</strong>，从而避免拥塞和丢包</p><ol><li>设置合适的延迟阈值RTT~max~</li><li>周期性测量分组的RTT</li><li>如果检测到RTT大于或接近RTT~max~，则认为网络出现了拥塞，降低发送速率</li><li>如果检测到RTT小于RTT~max~，则认为网络没有出现拥塞，增加发送速率</li></ol><h3 id="7-4-公平性">7.4 公平性</h3><p>公平：每条连接都得到相同份额的链路带宽</p><p>两条共享同一条传输速率为R的瓶颈链路的情况</p><ul><li><strong>全带宽</strong>：两条连接的吞吐量之和为R</li><li><strong>平等带宽</strong>：两条连接的吞吐量相同</li></ul><p>演变过程</p><ol><li>初始时刻位于A点，由于共同消耗的链路带宽小于R，两条连接都以相同的速率线性增长到B点</li><li>在B点时，由于共同消耗的链路带宽小于R，两条连接的吞吐量同时减半到C点</li><li>在C点时，由于共同消耗的链路带宽小于R，两条连接都以相同的速率线性增长到D点</li><li>以此类推，两条连接的带宽最终会收敛到平等带宽共享曲线和全带宽利用曲线的交叉点附近</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856571.png" alt=""></p><p>影响公平性的因素</p><ul><li><strong>UDP</strong>：UDP不具备拥塞控制机制，不会意识到网络的拥塞，UDP流量会挤压TCP流量</li><li><strong>并行TCP</strong>：单个程序创建并行TCP会争夺可用带宽，导致每个连接都获得较小的带宽份额，影响整体吞吐量</li></ul><h2 id="8-QUIC">8. QUIC</h2><p><strong>快速UDP互联网连接（Quick UDP Internet Connections,QUIC）</strong>：是建立在UDP运输层协议，但结合了TCP服务模式的应用层协议</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856572.png" alt=""></p><p>特征</p><ul><li><strong>面向连接</strong>：使用连接ID来标识连接，通过一次握手建立QUIC连接状态</li><li><strong>安全</strong>：在应用层集成了加密机制，减少了传统TLS和TCP握手中的延迟</li><li><strong>流</strong>：允许在一个QUIC连接中管理多个独立的数据流，每个流可以独立进行数据传输和流量控制</li><li><strong>可靠</strong>：提供了类似于TCP的可靠数据传输机制，包括重传丢失的数据包和确保数据的顺序</li><li><strong>拥塞控制</strong>：实现了先进的拥塞控制算法，用于动态调整数据传输速率，以应对网络拥塞情况</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wyw_0227/picture-bed/raw/master/Note/ComputerNetwork/chapter3/202408301856573.png" alt=""></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>运输层</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://dasi.net.cn/posts/bbea855c/">https://dasi.net.cn/posts/bbea855c/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:55px"><h>作者</h><div class="post-copyright-cc-info"><h>Dasi</h></div></div><div class="post-copyright-c" style="display:inline-block;width:105px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-22</h></div></div><div class="post-copyright-u" style="display:inline-block;width:105px"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-06</h></div></div><div class="post-copyright-c" style="display:inline-block;width:98px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%BD%91/">计网</a></div><div class="post_share"><div class="social-share" data-image="/image/cover_computernetwork.webp" data-sites="twitter,wechat,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.3" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js?v=1.1.3" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/5b80d779/" title="机器学习：绪论"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_machinelearning.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">机器学习：绪论</div><div class="content">机器学习的基本术语、版本空间、归纳偏好和发展历程</div></div></a></div><div class="next-post pull-right"><a href="/posts/6c5bbf5f/" title="什么是数据库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_database.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">什么是数据库</div><div class="content">数据库的基本知识，包括数据库系统、数据库面临问题、数据库视图、数据库语言、数据库引擎、数据库体系结构和数据库成员</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/99ade850/" title="因特网"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="title">因特网</div><div class="info">因特网，网络边缘，网络核心，分组交换网，协议层次和网络攻击</div></div></a></div><div><a href="/posts/ab07b2ac/" title="应用层"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="title">应用层</div><div class="info">client-server，HTTP，SMTP，DNS，CDN，P2P和socket</div></div></a></div><div><a href="/posts/e9eeac5f/" title="网络层-数据平面"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">网络层-数据平面</div><div class="info">路由器、IPv4和IPv6，NAT、DHCP、泛化转发、中间盒</div></div></a></div><div><a href="/posts/6bdcc3ed/" title="网络层-控制平面"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-14</div><div class="title">网络层-控制平面</div><div class="info">控制层面架构、路由选择算法、OSPF、BGP、SDN、ICMP、SNMP</div></div></a></div><div><a href="/posts/2a2781af/" title="链路层"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="title">链路层</div><div class="info">差错纠正技术、多路访问协议、交换局域网、MPLS、数据中心网络</div></div></a></div><div><a href="/posts/6938a174/" title="无线网络"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-09</div><div class="title">无线网络</div><div class="info">无线网络、无线链路、CDMA，WiFi、局域网、蓝牙</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-text">1. 运输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="toc-text">2. 多路复用与多路分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UDP"><span class="toc-text">3. UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-UDP%E6%80%A7%E8%B4%A8"><span class="toc-text">3.1 UDP性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-UDP%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-text">3.2 UDP报文段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="toc-text">4. 可靠数据传输原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.1 可靠数据传输协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-rdt1-0"><span class="toc-text">4.2 rdt1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-rdt2-x"><span class="toc-text">4.3 rdt2.x</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-rdt-2-0"><span class="toc-text">4.3.1 rdt.2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-rdt-2-1"><span class="toc-text">4.3.1 rdt.2.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-rdt2-2"><span class="toc-text">4.3.2 rdt2.2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-rdt3-0"><span class="toc-text">4.4 rdt3.0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-text">5. 流水线传输协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-text">5.1 流水线技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%9B%9E%E9%80%80N%E6%AD%A5"><span class="toc-text">5.2 回退N步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0"><span class="toc-text">5.3 选择重传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-TCP"><span class="toc-text">6. TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-TCP%E6%80%A7%E8%B4%A8"><span class="toc-text">6.1 TCP性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-text">6.2 TCP报文段结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-RTT%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-text">6.3 RTT和超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="toc-text">6.4 差错控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-TCP%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-text">6.4.1 TCP发送方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E7%B4%AF%E8%AE%A1%E7%A1%AE%E8%AE%A4"><span class="toc-text">6.4.2 累计确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E8%B6%85%E6%97%B6%E9%97%B4%E9%9A%94%E5%8A%A0%E5%80%8D"><span class="toc-text">6.4.3 超时间隔加倍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-text">6.4.4 快速重传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">6.5 流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">6.6 连接控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">6.6.1 建立连接：三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-%E7%BB%93%E6%9D%9F%E8%BF%9E%E6%8E%A5%EF%BC%9A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">6.6.2 结束连接：四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5"><span class="toc-text">6.6.3 终止连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7. 拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%8B%A5%E5%A1%9E%E5%8E%9F%E5%9B%A0%E4%B8%8E%E4%BB%A3%E4%BB%B7"><span class="toc-text">7.1 拥塞原因与代价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E6%97%A0%E9%99%90%E5%A4%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8D%95%E8%B7%B3%E8%B7%AF%E7%94%B1"><span class="toc-text">7.1.1 无限大缓存的单跳路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E6%9C%89%E9%99%90%E5%A4%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8D%95%E8%B7%B3%E8%B7%AF%E7%94%B1"><span class="toc-text">7.1.2 有限大缓存的单跳路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E6%9C%89%E9%99%90%E5%A4%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%9A%E8%B7%B3%E8%B7%AF%E7%94%B1"><span class="toc-text">7.1.3 有限大缓存的多跳路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7.2 TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E5%8E%9F%E7%90%86"><span class="toc-text">7.2.1 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E9%98%B6%E6%AE%B5"><span class="toc-text">7.2.2 阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E7%AE%97%E6%B3%95"><span class="toc-text">7.2.3 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%85%B6%E5%AE%83%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7.3 其它拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-ECN"><span class="toc-text">7.3.1 ECN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E5%9F%BA%E4%BA%8E%E6%97%B6%E5%BB%B6"><span class="toc-text">7.3.2 基于时延</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="toc-text">7.4 公平性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-QUIC"><span class="toc-text">8. QUIC</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Dasi</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa-solid fa-arrow-up"></i><span>置顶</span></a><a class="rightMenu-item" href="javascript:rmf.copyPageUrl();"><i class="fa-solid fa-link"></i><span>复制链接</span></a></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.33"></script><script src="/pluginsSrc/instant.page/instantpage.js?v=5.2.0" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js?v=17.8.8"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js?v=4.0.7").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css?v=0.16.9"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js?v=0.16.9"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.dasi.net.cn/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"==typeof twikoo?setTimeout(t,0):getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.31").then(t)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/rightmenu.js?1"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/rightside.js?1"></script><script src="/js/sitetitle.js?1"></script><script id="click-show-text" src="/pluginsSrc/butterfly-extsrc/dist/click-show-text.min.js?v=1.1.3" data-mobile="false" data-text="d,a,s,i" data-fontsize="20px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/7bb01bb2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_algorithm.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" href="posts/7bb01bb2/" alt="">动态规划</a><div class="blog-slider__text">介绍了动态规划的原理，并用4个典例进行了详细分析，总结过后完成经典DP问题</div><a class="blog-slider__button" href="posts/7bb01bb2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/46ae7d29/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_AI.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-28</span><a class="blog-slider__title" href="posts/46ae7d29/" alt="">α-β剪枝</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/46ae7d29/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/f11dbe61/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_git.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-13</span><a class="blog-slider__title" href="posts/f11dbe61/" alt="">Git基本操作</a><div class="blog-slider__text">介绍git的基本操作以及对git指令的理解</div><a class="blog-slider__button" href="posts/f11dbe61/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/57fa915c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_algorithm.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-14</span><a class="blog-slider__title" href="posts/57fa915c/" alt="">排序</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/57fa915c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/55f40959/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_AI.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-21</span><a class="blog-slider__title" href="posts/55f40959/" alt="">谓词逻辑的归结反演</a><div class="blog-slider__text">如何利用python实现谓词逻辑的归结反演，详细分析了每个函数</div><a class="blog-slider__button" href="posts/55f40959/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/bbea855c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-22</span><a class="blog-slider__title" href="posts/bbea855c/" alt="">运输层</a><div class="blog-slider__text">多路复用、多路分解、UDP和TCP、可靠数据传输原理、流水线模式和拥塞控制算法</div><a class="blog-slider__button" href="posts/bbea855c/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>