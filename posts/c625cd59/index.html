<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>分布式系统课程笔记汇总 | Dasi's Blog</title><meta name="author" content="Dasi"><meta name="copyright" content="Dasi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="定义、体系结构、进程、通信、命名、同步、一致、容错、协定、文件"><meta property="og:type" content="article"><meta property="og:title" content="分布式系统课程笔记汇总"><meta property="og:url" content="https://dasi.net.cn/posts/c625cd59/"><meta property="og:site_name" content="Dasi&#39;s Blog"><meta property="og:description" content="定义、体系结构、进程、通信、命名、同步、一致、容错、协定、文件"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dasi.net.cn/image/cover_distributedsystem.webp"><meta property="article:published_time" content="2024-12-30T12:40:22.000Z"><meta property="article:modified_time" content="2025-01-01T08:21:32.236Z"><meta property="article:author" content="Dasi"><meta property="article:tag" content="分布式系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://dasi.net.cn/image/cover_distributedsystem.webp"><link rel="shortcut icon" href="/image/avatar.webp"><link rel="canonical" href="https://dasi.net.cn/posts/c625cd59/"><link rel="preconnect"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-1sRsbKtiRS"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=6.5.1"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.33" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6230f5f166612db2398c773b5c5e2a61";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:8,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:250,languages:{author:"作者: Dasi",link:"链接: ",source:"来源: Dasi's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.11.1",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!1,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"分布式系统课程笔记汇总",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-01-01 16:21:32"}</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/tag.css?1"><link rel="stylesheet" href="/css/nav.css?1"><link rel="stylesheet" href="/css/homeArticle.css?1"><link rel="stylesheet" href="/css/category.css?1"><link rel="stylesheet" href="/css/cursor.css?1"><link rel="stylesheet" href="/css/background.css?1"><link rel="stylesheet" href="/css/rightmenu.css?1"><link rel="stylesheet" href="/css/copyright.css?1"><link rel="stylesheet" href="/css/archive.css?1"><link rel="stylesheet" href="/css/description.css?1"><link rel="stylesheet" href="/css/post.css?1"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",(()=>{o()}))})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/image/cover_distributedsystem.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Dasi's Blog"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp"><span class="site-name">Dasi's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式系统课程笔记汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-12-30T12:40:22.000Z" title="发表于 2024-12-30 20:40:22">2024-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="分布式系统课程笔记汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h1>分布式系统概述</h1><h2 id="分布式系统的定义">分布式系统的定义</h2><p>集中式系统：所有服务和计算都在一台或少数台计算机上进行，且这些计算机彼此之间物理互连</p><p>分布式系统产生的两大原因</p><ul><li><strong>高性能微处理器的开发</strong>，使得计算机的体积显著变小，同时计算性能维持较高水平</li><li><strong>高速计算机网络的发明</strong>，使得计算机之间通过计算机网络实现远距离通信和无线通信，同时保持高速传播</li></ul><p>分布式系统：<strong>是若干独立计算机的集合，这些计算机对于用户来说就像是单个耦合系统</strong></p><ul><li>硬件层面：计算机之间是彼此独立的</li><li>软件层面：用户只与自己的计算机进行交互</li><li>物理层面：计算机分布在不同的物理位置</li><li>逻辑层面：计算机是逻辑集中的和高耦合的</li></ul><p>中间件（Middleware）：位于操作系统和应用程序之间，属于软件层，屏蔽不同操作系统、网络协议、硬件架构的差异，<strong>为应用程序提供统一的接口</strong>，使计算机之间可以实现分布式任务</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233957.png" alt=""></p><h2 id="分布式系统的四个目标">分布式系统的四个目标</h2><p>资源可访问：计算机访问分布式系统中的资源就像访问本地资源一样快速简单</p><p>透明性：让用户意识不到分布式系统的底层工作或底层信息</p><ul><li>完全透明性难以实现，需要消耗更多资源来维持“无感知”状态，增加系统负担</li><li>完全透明性不可取，用户需要及时发现系统的性能问题，或者需要暴露系统特征来为用户提供个性化服务</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601881.png" alt=""></p><p>开放性：分布式系统根据一系列准则来提供服务，通过标准化接口使得不同服务之间可以进行交互</p><ul><li><strong>互操作性</strong>：不同系统、应用或组件之间能够无缝协同工作，互相交换和理解数据</li><li><strong>可移植性</strong>：应用或组件可以在不同的硬件或软件环境之间迁移而不需要修改或仅需最小的修改</li><li><strong>灵活性</strong>：系统能够根据需求变化快速进行调整和扩展而不影响系统的整体架构</li></ul><p>可扩展性：分布式系统可以伸缩、增减</p><ul><li><strong>规模</strong>：分布式系统能够随着需求的增长而增加资源和用户</li><li><strong>地域</strong>：分布式系统系统可以跨多个地理区域部署</li><li><strong>管理</strong>：随着系统规模和复杂性的增加，系统的管理和维护工作量不会显著增加</li></ul><h2 id="分布式系统的分类">分布式系统的分类</h2><h3 id="分布式计算系统">分布式计算系统</h3><p><strong>集群计算系统</strong>：多台通过网络连接计算机组成的计算系统，每台计算机是同构的，单个程序可以在多台计算机上并行运行<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233951.png" alt=""></p><p><strong>网格计算系统</strong>：由来自各地的节点组成的计算系统，每台计算机是异构的，通过虚拟分层组织来实现一组计算机之间的协同工作<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233952.png" alt=""></p><p><strong>云计算系统</strong>：由云服务提供商建立的面向服务的计算系统，通常由大量服务器和数据库在一个位置组成，通过网络和虚拟化技术为用户提供计算服务<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233953.png" alt=""></p><h3 id="分布式信息系统">分布式信息系统</h3><p><strong>事务处理系统</strong>：通过事务监视器保证事务的正确执行，确保数据的正确性<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233954.png" alt=""></p><p>企业应用集成：通过中间件将客户端的请求合并，分散到各个服务器处理，同时企业内部各个独立的服务器和应用程序之间也可以进行通信<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter1/202411141233956.png" alt=""></p><h3 id="分布式普适系统">分布式普适系统</h3><p>普适计算系统：计算无处不在，被无缝集成到人们的生活和工作中（嵌入式设备）</p><p>移动计算系统：用户可以通过移动设备在任何时间、任何地点访问数据和应用（手机、平板）</p><p>无线传感器网络：是一组分布式的传感器节点，通过自组织网络相互连接，用于环境监测和物理数据收集（火警检测器）</p><h3 id="区分">区分</h3><table><thead><tr><th>类型</th><th>计算系统</th><th>信息系统</th><th>普适系统</th></tr></thead><tbody><tr><td>核心功能</td><td>数据计算</td><td>信息处理</td><td>智能化服务</td></tr><tr><td>数据处理</td><td>计算大规模、复杂的数据</td><td>存储和分析带有信息的数据</td><td>实时地数据采集和响应</td></tr><tr><td>交互方式</td><td>基于命令行、程序开发和高级算法设计</td><td>通过图形界面、报表和仪表板等方式</td><td>通过语音、触控、体感、环境监测等方式</td></tr><tr><td>示例</td><td>超级计算机</td><td>客户端-服务器架构</td><td>智能家居</td></tr><tr><td>适用领域</td><td>科研、数据分析</td><td>企业管理</td><td>物联网、个性化服务、生态环境</td></tr></tbody></table><h1>体系结构</h1><h2 id="样式">样式</h2><p>样式决定了组件之间相互的连接方式、组件之间的数据交换以及这些组件如何集成到一个系统中</p><p><strong>分层</strong>：将系统功能划分为多个层次，每一层实现特定的功能，系统的各个组件通过接口并遵循协议来进行交互，通常来说请求是自顶向下的，响应是自底向上的<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034889.png" alt=""></p><p><strong>基于对象</strong>：每个对象对应一个组件，对象既封装了数据，也封装了面向数据的处理方法，组件之间可以通过远程调用方法的机制来连接、通信和交互<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034872.png" alt=""></p><p><strong>基于数据</strong>：不同组件通过访问共享的数据库或存储系统来进行协作<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034874.png" alt=""></p><p><strong>基于事件</strong>：各个组件可以独立处理事件，组件之间通过发布/订阅系统来实现事件传播<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034875.png" alt=""></p><h2 id="类型">类型</h2><h3 id="集中式架构">集中式架构</h3><p>集中式架构：系统的所有主要计算和决策逻辑都集中在一个或少数几个服务器上，客户端主要负责用户交互和简单的请求转发</p><ul><li>应用分层：应用程序被划分为多层，每一层专注于完成特定任务，每层之间通过定义明确的接口进行通信</li><li>多层：是对分层架构的扩展，加入了额外的层级以支持复杂功能和大规模分布式部署</li></ul><p>Web的三层架构</p><ol><li>用户接口：为用户提供访问应用程序的方式</li><li>处理层：应用程序的实现，负责业务逻辑和数据处理</li><li>数据层：存储、管理和维护应用中的数据<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034877.png" alt=""></li></ol><p>客户端-服务器的组织结构</p><ul><li>瘦客户：客户端只实现用户接口层，服务器实现处理层和数据层</li><li>胖客户：在客户端添加部分业务逻辑和数据存储<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034878.png" alt=""></li></ul><h3 id="非集中式架构">非集中式架构</h3><p>非集中式架构：系统中的所有节点平等，彼此协作完成任务，而没有中心控制节点，每个节点既可以是客户端，也可以是服务器</p><p>结构化P2P：基于分布式哈希表将节点组织在一个特定拓扑结构的覆盖网络中</p><p>非结构化P2P：基于随机图将节点组织在一个松散耦合的网络中，即每个节点只连接到随机选择的其他节点</p><ul><li>泛洪：节点接收到请求后，将请求广播给所有邻居节点，使得信息逐层传播</li><li>随机游走：请求通过随机路径在节点间传递，每一步随机选择一个邻居进行传递</li></ul><p>分层P2P：部分节点充当“超级对等节点”，负责核心的管理和路由任务，而其他节点则充当普通节点，普通节点只能与超级节点连接，超级节点之间相互连接<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034882.png" alt=""></p><h3 id="混合式">混合式</h3><p>混合式架构：结合了集中式和分散式的特点，既有中心服务器提供核心功能，又利用分布式节点来提升性能和扩展性</p><p>边界服务器系统：边界服务器处理终端用户的请求，将其转发到内部网络进行处理（CDN）<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034883.png" alt=""></p><p>协作分布式系统：客户节点和服务节点的角色是动态的，跟踪器只用来决定谁作为服务节点，但不提供计算服务<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034884.png" alt=""></p><h2 id="中间件与体系结构">中间件与体系结构</h2><p>适配器（adapter）：适配器将不同接口的类连接起来，使得原本不兼容的接口能够一起工作<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034885.png" alt=""></p><p>代理（broker）：通过一个中介来解耦请求的发送者与接收者，管理服务请求和响应<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034886.png" alt=""></p><p>中断（interceptor）：允许在请求处理的过程中插入自定义逻辑<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034887.png" alt=""></p><h2 id="自治体系结构">自治体系结构</h2><p>自治的体现：自我管理、自我恢复、自我配置、自我优化等</p><p>反馈控制循环</p><ul><li>监控：收集系统运行状态的实时数据</li><li>分析：评估监控数据，确定系统是否符合设定的性能目标，以及是否出现偏差或异常</li><li>计划：制定纠正措施、优化策略和调整方法，以便系统可以回到期望状态</li><li>纠正/执行：根据调整措施执行新的操作</li><li>反馈：执行后的状态信息会再次反馈到监控模块</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter2/202411142034888.png" alt=""></p><h1>进程</h1><h2 id="进程与线程">进程与线程</h2><p>区分进程和线程</p><table><thead><tr><th>类型</th><th>定义</th><th>上下文内容</th><th>特点</th></tr></thead><tbody><tr><td>进程</td><td>独立运行的程序实例</td><td>有自己的独立地址空间，还记录CPU、内存管理单元和转换后备缓冲器的资源信息</td><td>粗粒度、独立性强、切换成本高、通信需要依靠IPC</td></tr><tr><td>线程</td><td>是进程中的一个执行路径，是最小可执行一系列指令的软件处理器</td><td>共享进程的地址空间和全局资源，但有自己的寄存器状态</td><td>细粒度、共享资源、通信简单、轻量级</td></tr></tbody></table><p>多线程进程的优势</p><ul><li>允许使用会导致线程阻塞的系统调用，但是却不阻塞该线程所属的进程</li><li>可以在多核CPU上更好地发挥并行性</li><li>避免频繁且高开销的进程上下文切换</li></ul><p>多线程客户端：客户端派生多个线程，每一个线程负责一个调用，适合调用目标是不同的服务器，将会得到线性加速。比如说浏览器获取网页内容，只要浏览器获得html文件，就可以根据html文件中的多个url来激活多个独立的线程</p><p>多线程服务器：服务器建立一个分发者线程和多个工作者线程，分发者线程用于接收来自网络的请求，然后将请求内容按需分配给工作者线程执行<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601933.png" alt=""></p><h2 id="虚拟化">虚拟化</h2><h3 id="虚拟化作用">虚拟化作用</h3><p>虚拟化：通过软件技术抽象物理资源为逻辑资源</p><ul><li>提高资源利用率：可以根据需求动态调整资源分配</li><li>提供跨平台支持：屏蔽底层硬件和操作系统差异</li><li>新硬件适配：通过虚拟化技术延长旧应用的使用寿命</li><li>集中管理分布式的资源：利用虚拟化平台集中管理逻辑资源</li><li>提高系统可靠性和可用性：支持快照和容灾备份机制</li></ul><h3 id="虚拟化技术">虚拟化技术</h3><p>计算机系统的接口（自底向上）</p><ol><li>由机器指令组成，可由任何程序激起的软件-硬件接口</li><li>由机器指令组成，只能有特权程序才可激活的软件-硬件接口</li><li>由系统调用组成的操作系统接口</li><li>由库函数组成的应用程序编程接口（API）</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601867.png" alt=""></p><p>虚拟化技术</p><ul><li>进程虚拟机（Process VM）：运行在操作系统之上，抽象了底层硬件和操作系统的差异，使得应用程序可以在不同平台上无缝运行</li><li>原生虚拟机监控器（Native VMM）：运行在物理硬件之上，直接与物理硬件交互，为虚拟机分配和管理硬件资源</li><li>主机虚拟机监控器（Hosted VMM）：运行在宿主操作系统之上，直接与宿主操作系统交互，为虚拟机分配和管理硬件资源</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601869.png" alt=""></p><h3 id="云计算技术">云计算技术</h3><ul><li>基础设施即服务（Infrastructure-as-a-Service, IaaS）：提供虚拟化的硬件资源，如存储空间、网络带宽等</li><li>平台即服务（Platform-as-a-Service, PaaS）：提供虚拟化的开发和运行平台，开发者可以在这个平台上编写、测试、部署应用，而不必担心底层硬件、操作系统、存储和网络等基础设施</li><li>软件即服务（Software-as-a-Service, SaaS）：提供虚拟化的应用服务，用户可以通过浏览器等轻量级客户端访问和使用这些应用，而无需安装和管理软件</li></ul><h2 id="客户端">客户端</h2><p>客户端定义：向用户提供接口，与远程服务器进行交互，并接收来自服务器的数据以展示的程序或设备，客户端与服务器之间的通信通常通过网络进行</p><p>客户端的网络接口</p><ul><li>应用特定（App Specific）：为特定应用程序量身定制，具备与该应用密切相关的功能和设计，如音乐软件、游戏软件等</li><li>应用无关（App Independent）：通用接口，不依赖于特定的应用逻辑，可以被不同的应用所使用，如浏览器</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601870.png" alt=""></p><p>客户端实现透明性：意识不到服务器的位置，意识不到服务器是否切换，意识不到服务器是否故障，意识不到是否将请求发送给多个服务器</p><ul><li>存根（stub）：是远程服务的接口，负责将客户端调用的请求打包传递给服务器，隐藏了网络通信和远程调用的细节，确保客户端可以像调用本地方法一样调用远程方法</li><li>代理（proxy）：充当了客户端和实际远程服务之间的中间件，具有处理服务器故障、客户端复制请求和服务器重定位等功能</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601871.png" alt=""></p><h2 id="服务器">服务器</h2><h3 id="基本模式">基本模式</h3><p>【服务器组织结构】</p><table><thead><tr><th>服务器的组织结构</th><th>迭代（iterative）</th><th>并发（concurrent）</th></tr></thead><tbody><tr><td>定义</td><td>一次只处理一个客户端请求，在完成请求后才会处理下一个请求</td><td>可以同时处理多个客户端请求，同时为多个客户端提供服务</td></tr><tr><td>流程</td><td>用队列记录请求，按顺序一个接一个处理</td><td>为请求创建一个新的线程或进程单独处理</td></tr><tr><td>优势</td><td>编程简单，适用于单个请求处理时间较短的场景</td><td>具有高吞吐量和响应速度</td></tr><tr><td>缺点</td><td>会阻塞后续请求，造成长响应时间</td><td>需要处理资源竞争、数据死锁等问题</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601872.png" alt=""></p><p>【服务器状态】</p><p>｜状态｜状态相关的（stateful）｜状态无关的（stateless）｜<br>｜-｜-｜-｜<br>｜定义｜在处理客户端请求时，会维护客户端的状态信息，如上下文信息和历史信息｜服务器对每个请求是独立的，不记录任何客户端状态信息｜<br>｜优点｜减少数据传输次数，减小请求消息大小｜服务器崩溃不会影响客户端状态｜<br>｜缺点｜需要复杂的同步机制和额外的存储空间｜需要客户端一次性发送请求全部内容｜</p><div class="note info flat"><p>RESTful API是遵循REST原则的统一接口，直接使用HTTP中的各种方法来定义对资源的操作，如GET、PUT、POST、DELETE等，其中资源在网络中由URL标识，服务器不会保留客户端对状态信息，客户端需要在每次请求中包含足够的信息以完成请求</p></div><p>【服务器发现】</p><p>静态分配：客户端直接使用固定的端口号和地址来访问服务器，比如说HTTP服务通常运行在80端口</p><p>目录服务器：服务器将自己的端口和地址注册到目录中，客户端访问并查询目录服务器来获取可用的服务器<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601873.png" alt=""></p><p>超级服务器：不处理请求，而是负责根据请求选择合适的服务器实例<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601874.png" alt=""></p><h3 id="服务器集群">服务器集群</h3><p>【三层结构】</p><ol><li>负载均衡器/逻辑交换机：分配客户请求</li><li>服务器：处理客户请求</li><li>数据库：处理数据读写</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601875.png" alt=""></p><p>【TCP handoff】</p><p>客户端向服务器集群中的负载均衡器发送请求，负载均衡器将请求转发给对应的服务器，同时修改请求的目的地址为服务器地址，从而建立连接</p><ul><li>轮询：按指定顺序，依次分发到不同服务器</li><li>基于服务类型：网页请求分发到Web服务器，文件请求分发到FTP服务器</li><li>基于服务器负载：监控每个服务器的负载情况，将请求分配到负载较低的服务器</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601876.png" alt=""></p><p>【请求内容混合分发】</p><ul><li>switch交换机：将请求转发给分发器和服务器</li><li>dispatcher调度器：检查请求的具体内容，确定最合适的服务器</li><li>distributor分发器：根据调度器提供的信息，转发请求到对应服务器，并通知交换机</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601877.png" alt=""></p><p>【分布式服务器】</p><p>提供一个稳定的访问点（HoA），使得客户能够无缝访问服务，但没有感知到分布式服务器的动态变化，客户端的视角下只是一个强大的服务器。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601878.png" alt=""></p><h2 id="代码迁移">代码迁移</h2><h3 id="基本迁移">基本迁移</h3><p>定义：将代码从一个节点移动到另一个节点运行的过程</p><ul><li>负载均衡：将计算任务从繁忙的服务器迁移到空闲服务器</li><li>最小化通信：将代码迁移到存储数据的节点可以减少网络通信的开销</li><li>移动性支持：确保移动设备的服务连续性</li></ul><p>进程迁移的组成</p><ul><li>指令段：包含程序的所有代码</li><li>资源段：包含程序所需的所有外部资源（设备访问、数据库连接、文件访问）</li><li>执行状态段：包含程序运行时的状态（变量值、程序堆栈）</li></ul><p>类型</p><ul><li>弱迁移：只迁移代码段，目标节点需要重新初始化运行环境，从起点开始运行</li><li>强迁移：迁移代码段和执行状态段，目标节点从迁移中断的地方继续执行</li></ul><h3 id="资源段处理">资源段处理</h3><p>资源绑定方式</p><ul><li>未连接（Unattached）：资源未绑定到任何特定机器，可以动态分配和移动。</li><li>附着连接（Attached）：资源附加到某一特定机器，但仍然可以移动。</li><li>紧固连接（Fixed）：资源绑定到特定机器，不能移动。</li></ul><p>绑定策略</p><ul><li>GR（Global Reference，全局引用）：创建一个系统范围内的全局引用</li><li>MV（Move，移动资源）：将资源移动到当前需要使用的机器</li><li>CP（Copy，复制资源的值）：复制资源的值到需要的机器上</li><li>RB（Rebind，重新绑定资源）：将进程重新绑定到本地可用资源</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601879.png" alt=""></p><h3 id="异构系统的迁移">异构系统的迁移</h3><p>异构系统指的是由不同的硬件架构、操作系统、编程语言或运行环境组成的系统，迁移后的代码可能不适合在目标机器上执行。</p><ul><li>抽象机：在不同平台上构建抽象层，使迁移代码运行在统一的抽象环境中，而无需关心底层硬件和操作系统</li><li>解释型语言：使得代码能在不同平台上通过解释器运行</li><li>虚拟机监控器：利用虚拟化技术在目标节点模拟一个与源节点一致的环境，使迁移的代码能够无缝运行</li></ul><p>虚拟机迁移：将整个虚拟机实例迁移</p><ul><li>静态迁移：停止当前的虚拟机，迁移内存，然后重新启动虚拟机</li><li>动态迁移：将源虚拟机的内存内容逐步推送到目标主机，在迁移过程中，如果出现脏页，则重新发送这些页面</li></ul><h1>进程通信</h1><h2 id="网络通信">网络通信</h2><p>协议：对规则归纳总结，并加以形式化</p><p>OSI模型<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601884.png" alt=""></p><p>中间件协议</p><ul><li>提供高级通信协议</li><li>实现数据包装和解包装</li><li>支持资源命名和动态发现</li><li>提供复制和缓存优化性能</li></ul><h2 id="远程过程调用">远程过程调用</h2><h3 id="RPC-概念">RPC 概念</h3><p>RPC特性</p><ul><li>透明性：对用户来说，远程调用和本地调用几乎没有区别，隐藏了网络通信的细</li><li>同步调用：调用方在收到返回结果前会被阻塞，适合紧耦合的服务交互</li></ul><p>存根：客户端存根负责将远程过程调用转化为一个网络请求消息，并将传递参数依据通用格式封装进请求中，发送给服务器存根，服务器存根解析请求消息，得到传递参数，然后执行远程过程，将结果再通过消息返回给客户端存根<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601880.png" alt=""></p><p>客户端-服务器绑定：先通过目录服务器找到服务器所在的机器，然后在目标机器上找到运行服务器的进程<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601882.png" alt=""></p><h3 id="RPC-类型">RPC 类型</h3><ul><li>普通RPC：客户端发送请求后等待服务器返回结果</li><li>异步RPC：客户端发送请求后只等待只等待请求被接收的确认，无需等待服务器的处理请求的结果，客户端可以继续执行其他任务</li><li>延迟异步RPC：在异步RPC的基础上，服务器处理完请求后，主动通知客户端结果，然后等待来自客户端对结果的确认</li><li>多播RPC：发送RPC请求到一组服务器上</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601883.png" alt=""></p><h2 id="面向消息的通信">面向消息的通信</h2><h3 id="瞬态通信">瞬态通信</h3><p>瞬态通信（Transient）：通信双方需要同时在线</p><p>套接字（Socket）：一种通信端点，应用程序通过套接字直接进行消息传递<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601885.png" alt=""><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601886.png" alt=""></p><p>消息传递接口（Message-Passing Interface, MPI）：是一种用于并行计算和分布式计算的标准化消息传递库接口<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601887.png" alt=""></p><h3 id="持久通信">持久通信</h3><p>持久通信（Persistent）：在发送方和接收方不需要同时在线的情况下，依然能够确保消息的可靠传递</p><p>消息队列系统：发送方将请求消息放入队列后即可继续处理其他任务，接收方按需从队列中获取消息，发送方不需要在接收方运行的时候才能发送请求，接收方也不需要在发送方运行的时候才能处理请求<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601888.png" alt=""></p><p>队列管理器：查找映射信息，将消息从发送方路由到目标队列所在的主机和端口<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601889.png" alt=""></p><p>消息路由器：对消息进行路由与转发，确保消息能够准确地从发送方传递到接收方，也就是说，队列管理器不将消息发给目标队列，而是发给消息路由器，减少本次存储消耗，将工作转移到消息路由器来处理<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601890.png" alt=""></p><p>消息转换器：解决不同应用或系统之间消息格式不兼容的问题，将输入消息转换为目标应用能够识别和处理的格式<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601891.png" alt=""></p><h2 id="面向流的通信">面向流的通信</h2><p>面向流的通信：是一种专注于连续数据传输的通信方式</p><ul><li>连续性：数据以连续的流形式传输，而不是独立的消息或分段</li><li>时间敏感：对延迟和抖动有较高要求</li><li>双向通信：支持互相通信</li></ul><p>服务质量（Quality of Service, QoS）</p><ul><li>数据传输的比特率</li><li>创建会话的最大延时</li><li>端到端的最大延时</li><li>最大延时抖动</li><li>最大往返延时</li></ul><p>QoS技术</p><ul><li>缓冲区：调节速率差异，减少丢包和延迟，提高传输效率</li><li>编码：压缩数据提高效率，或加入冗余信息检测和纠正传输错误</li><li>帧交织：分散传输错误，减少连续错误的影响，提高数据恢复能力</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601892.png" alt=""></p><h2 id="多播通信">多播通信</h2><h3 id="基于网络协议">基于网络协议</h3><p>直接使用IP协议实现多播功能，将数据包高效地发送到一组接收方</p><ul><li>成本高：网络层支持多播通常需要专门的硬件配置和路由协议</li><li>部署受限：多播路由器和协议通常不在公共网络上部署，否则会造成大量网络拥堵</li></ul><h3 id="基于覆盖网络（Overlay）">基于覆盖网络（Overlay）</h3><p>Overlay Network：在应用层构建一个覆盖网络，用逻辑连接代替底层物理连接，在应用层通过逻辑连接确定多播的接收方<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601893.png" alt=""></p><p>评估</p><ul><li>链路压力：一个数据包在多播通信中重复经过同一个链路的次数</li><li>延迟比：覆盖网络中两个节点之间的通信延迟与底层物理网络中直接通信的延迟的比值</li><li>树成本：多播树中所有链路成本的总和，通常由链路的带宽占用、延迟、跳数等指标决定</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601894.png" alt=""></p><h3 id="基于Gossip">基于Gossip</h3><p>闲聊/感染协议：基于局部信息和概率传播的多播方式</p><ul><li>每个节点只需了解直接相邻的节点，不需要全局的拓扑信息</li><li>节点接收到数据后，随机选择若干目的地，将消息传播给它们</li><li>无严格交付保证，需要多轮传播，才能确保消息会覆盖网络大部分节点</li><li>适合高并发的分布式系统中，多节点间的状态同步或数据广播</li><li>存在消息冗余，浪费带宽资源</li><li>延迟较大，需多轮传播</li></ul><h3 id="总结">总结</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601895.png" alt=""></p><ul><li>Overlay适合数据分发和实时通信，如分布式文件共享和流媒体分发</li><li>Gossip适合状态同步和数据广播，如分布式数据库和动态传感器网络</li></ul><h1>命名系统</h1><h2 id="基本概念">基本概念</h2><p>命名系统：用于标识和访问分布式系统中资源的机制，通过名称将资源与其具体位置或属性关联起来，便于用户和系统之间的交互</p><p>组成</p><ul><li>名称：标识分布式系统中实体对象的可读字符串</li><li>标识符：唯一标识分布式系统中某个实体的名称</li><li>实体：分布式系统中的任何事物</li><li>访问点：访问实体的入口，提供与实体交互的接口</li><li>地址：访问点的名称，提供实体的物理或逻辑位置</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601896.png" alt=""></p><h2 id="无层次命名">无层次命名</h2><p>定义：命名只是单纯的标识符，可能是随机生成的字符串，没有层次结构，不包含位置信息</p><p>基于网络：通过网络广播或多播的方式查询目标名称对应的实体或资源（ARP协议）</p><p>转发指针：当实体移动时，在当前位置留下到下一个位置的<br>指针，客户端只需要沿着指针链搜索，找到之后更新自己的指针记录<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601897.png" alt=""></p><p>宿主地址：利用一个固定位置的宿主主机记录实体地址，客户端需要联系宿主获取实体地址<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601898.png" alt=""></p><p>分层定位：创建一个大规模的搜索树，底层的网络被划分成多个分层的域，每一个域由一个目录节点表示，实体地址存储在叶子节点上<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601899.png" alt=""></p><p>分布式哈希表（DHT）：将每个实体和资源的名称通过哈希函数映射为固定长度的键值，从客户端出发，通过邻居信息逐步查询，直到找到目标键值的后继节点</p><p>Chord系统</p><ul><li>实体有键值，资源也有键值，且他们是不冲突的</li><li>资源存储在第一个实体键值大于等于其资源键值的实体上</li><li>键值有m位，则键值范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 ～ 2^m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6644em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span></li><li>键值有m位，则指状表有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span>条栏目</li><li>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6595em"></span><span class="mord mathnormal">i</span></span></span></span>条栏目指向距离当前节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mo stretchy="false">(</mo></msup><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9713em;vertical-align:-.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.888em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>后的第一个存在节点</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601900.png" alt=""></p><h2 id="结构化命名">结构化命名</h2><p>无层次名称只适用于机器理解，结构化命名适合人类阅读，比如基于目录结构的文件命名和基于层次的主机命名</p><p>命名图：叶节点标识实体名称，还可以存储实体属性等信息，非叶子节点作为目录节点具有多条边<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601901.png" alt=""></p><p>命名空间</p><ul><li>全局层：由根节点以及其他逻辑上靠近根节点的目录节点组成</li><li>行政层：由那些在单个组织内一起被管理的目录节点组成</li><li>管理层：由经常改变的节点组成</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601905.png" alt=""></p><p>迭代式解析：客户端负责主动与每一级名称服务器交互，每次请求一个服务器，获取下一步的解析地址，直到最终获取资源的具体地址<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601902.png" alt=""></p><p>递归式解析：客户端将解析请求交给一个名称服务器，由该名称服务器代替客户端完成所有后续解析，最终将结果返回给客户端<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601904.png" alt=""></p><h2 id="基于属性的命名">基于属性的命名</h2><p>定义：直接通过实体的属性和值对资源进行标识和查询，而不是依赖简单的名称</p><ul><li>意义：通过实体的属性查询实体很方便</li><li>挑战：查找操作代价高，需要进行属性值匹配和比对</li></ul><p>实现方式</p><ul><li>集中式目录服务：所有属性和值数据存储在一个中心化的目录服务器中</li><li>层次化目录服务（LDAP）：属性和值以目录信息树的层次结构组织，每个节点表示一个属性</li><li>去中心化目录服务：属性和值分布式存储在多个节点中，没有单一的目录服务器</li><li>语义覆盖网络：节点按照特定的属性值语义（如主题、内容、属性等）进行组织和连接，只连接具有相似语义兴趣的节点</li></ul><h1>同步性</h1><h2 id="时钟">时钟</h2><h3 id="网络时间协议">网络时间协议</h3><p>网络时间协议（Network Time Protocol, NTP）：客户端向时间服务器发送时间同步请求，服务器返回当前时间、时间戳和其他相关信息，客户端计算往返延迟并校正本地时钟<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601906.png" alt=""></p><p>客户端修复：选择时间延迟最小值作为服务器之间的延迟，对应的时间偏移更可靠</p><ul><li>时间偏移 =<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>偏移</mtext><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>T</mi><mn>2</mn><mo>−</mo><mi>T</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>T</mi><mn>3</mn><mo>−</mo><mi>T</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\text{偏移} = \frac{(T2 - T1) + (T3 - T4)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord text"><span class="mord cjk_fallback">偏移</span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>时间延迟 =<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>偏移</mtext><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>T</mi><mn>2</mn><mo>−</mo><mi>T</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>T</mi><mn>4</mn><mo>−</mo><mi>T</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\text{偏移} = \frac{(T2 - T1) + (T4 - T3)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord text"><span class="mord cjk_fallback">偏移</span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">4</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul><h3 id="Berkeley算法">Berkeley算法</h3><p>Berkeley算法：通过系统中的各节点相互协作，计算出一个统一的平均时间，并调整各节点的本地时钟，使其尽可能同步</p><ol><li>选出一个节点作为协调者/时间守护程序，负责时间同步的计算和协调</li><li>协调者向所有节点发送时间请求</li><li>各节点将其本地时钟值连同响应的网络延迟返回给协调者</li><li>协调者根据收到的时钟值和估算的网络延迟，计算系统中所有时钟的平均时间</li><li>协调者计算每个节点的时间偏差，将偏差值发送给各节点，通知它们调整本地时钟</li><li>各节点根据接收到的偏差值调整本地时钟，使其接近平均时间</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601907.png" alt=""></p><h3 id="Lamport算法">Lamport算法</h3><p>逻辑时钟：关心事件发生的相对顺序，而不关心事件的实际发生时间</p><p>基于“Happens-before”</p><ul><li>相同进程内，如果a先于b发生，则a-&gt;b</li><li>不同进程间，如果a向b发送消息，则a-&gt;b</li><li>如果a-&gt;b,b-&gt;c则a-&gt;c</li><li>如果a和b无法通过上述两个规则定义顺序，则a||b</li></ul><p>Lamport算法：每个进程维护一个本地计数器C</p><ol><li>每次发生一个事件，进程将自己的计数器的值+1</li><li>进程发送消息给其他进程时，需要携带自己的时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>s</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ts(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>进程收到消息后，根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>t</mi><mi>s</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C_j = \max(C_j, ts(m)) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9694em;vertical-align:-.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-.2861em"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>$调整自己的本地计数器</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601908.png" alt=""></p><p>全序多播：确保所有进程以相同顺序交付消息</p><ol><li>消息发送：P_1 发送消息 m_1，附加时间戳 ts(m_1) = 1，并将消息存入自己的队列 queue_1。</li><li>消息接收：P_2 接收到消息 m_1，将其放入自己的队列 queue_2，并广播确认消息</li><li>消息排序：每个进程根据消息时间戳对队列中的消息进行排序。</li><li>消息交付：当所有进程都收到了 m_1 的确认消息，且 m_1 是 P_2 的队列头部时，P_2 才会将 m_1 交付给应用程序。</li></ol><p>局限性</p><ul><li>Lamport算法只能说a在b之前发生，但不代表b发生和a有关系</li><li>Lamport算法无法区分并发事件</li></ul><h3 id="向量时钟">向量时钟</h3><p>基于因果关系（causality）：如果a的向量时钟的全部分量都小于b的向量时钟，说明a有可能在因果关系上先于b，否则它们可能是并发的</p><p>向量时钟算法：每个进程维护维护一个向量时钟，每个分量 V_i[k] 表示当前进程 P_i 所知道的关于进程 k 的逻辑时钟</p><ol><li>本地事件：当一个进程 P_i 执行一个事件时，更新向量时钟自己的分量，V_i[i] = V_i[i] + 1</li><li>发送消息：当 P_i 发送一条消息 m 时，它将当前的向量时钟 V_i 附加到消息中，作为消息的时间戳 V_m</li><li>接收消息 当 P_j 接收消息 m 时，逐一更新每个进程的时钟，V_j[k] = \max(V_j[k], V_m[k])</li><li>交付消息：P_j 增加自己的分量，V_j[j] = V_j[j] + 1</li></ol><p>强制因果有序：P_j 交付 P_i 的消息 m 当且仅当</p><ul><li>P_j 希望接收 m：V_j[i] + 1 = V_m[i]</li><li>P_j 已经接收了所有前置消息：V_j[k] &gt;= V_m[k] (k != i)</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601909.png" alt=""></p><h2 id="互斥">互斥</h2><p>互斥：同一时间内，共享资源只能由一个进程访问</p><p>集中式算法：选举一个进程作为协作者，进程需要向协作者发送资源请求，协作者根据全局信息来判断请求是否被允许<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601912.png" alt=""></p><p>Ricart &amp; Agrawala算法：当进程要访问一个共享资源的时候，需要构造一个请求消息，发布给全部进程（包括自己），当且仅当接收到全部进程的OK消息，才能使用该资源</p><ol><li>接收进程在临界区内没有访问需求，直接返回OK</li><li>接收进程在临界区已获得对资源的访问，不应答，将请求放入队列</li><li>接收进程也在请求该资源，如果收到消息的时间戳比自己请求的时间戳小，则返回OK，将请求放入队列</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601910.png" alt=""></p><p>令牌环算法：将进程组织成逻辑环，令牌在这些进程之间传递，只有获得令牌的进程才能进入临界区访问共享资源<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601911.png" alt=""></p><h2 id="选举">选举</h2><p>选举：分布式系统中需要选取一个进程来作为特殊角色，实现特殊功能</p><p>Bully算法：假定每个节点都有唯一的 ID，ID 越大优先级越高</p><ol><li>如果节点发现当前的领导者失效（或未能响应），发起者向所有比自己 ID 大的节点发送选举消息</li><li>收到选举消息的节点会回应，表明自己存活，同时如果自己的 ID 更大，它会成为新的发起者，再次向所有比自己 ID 大的节点发送选举消息</li><li>如果某一阶段发起者没有收到任何回应，说明它的优先级最高，它将广播宣布自己为领导者</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601913.png" alt=""></p><p>Ring算法：假定所有节点组织成一个逻辑环，每个节点仅与它的前后节点直接通信</p><ol><li>如果节点发现领导者失效，它会将自己的 ID 放入选举消息中，并传递给下一个节点</li><li>每个节点收到选举消息后，比较消息中的 ID 与自己的 ID，选择较大的 ID，将消息继续传递</li><li>当消息传递一圈回到发起者时，发起者发现消息中的 ID 是最大的，宣布该 ID 的节点为新领导者，并广播确认消息</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601914.png" alt=""></p><h1>一致性</h1><h2 id="副本管理">副本管理</h2><p>副本的意义</p><ul><li>提高可靠性：即使某些节点故障，仍可以使用其他副本来维持服务</li><li>提高性能：副本的数量和位置可以根据客户端的地理分布或请求负载动态调整</li></ul><p>副本放置</p><ul><li>客户端感知：最小化客户端与副本服务器之间的平均距离，从而降低访问延迟</li><li>客户端非感知：优先选择具有最大带宽的来部署副本服务器</li><li>基于区域：在每个区域内选择一个低延迟节点部署副本</li></ul><p>副本类型</p><ul><li>永久副本：在系统设计时就静态配置，是稳定的存储节点，用于长期保存数据</li><li>服务器发起的副本：由服务器根据负载或访问模式动态生成和管理，用于优化系统性能</li><li>客户端发起的副本：当客户端访问某些数据时，本地保存一份缓存副本以降低重复请求</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601917.png" alt=""></p><p>内容分发</p><ul><li>类型：传播更新通知，传播更新数据，传播更新操作</li><li>推送机制：服务器主动向副本推送更新，适合读多写少的场景，客户端可以即时获取最新数据，但是可能导致不必要的网络开销</li><li>拉取机制：客户端或副本主动从服务器拉取更新，适合读少写多的场景，可以降低服务器负担，但是客户端可能会延迟获取最新数据</li></ul><p>CAP理论：一致性、可用性和分区容忍性不可兼得，因此分布式系统通常要牺牲一定程度的一致性</p><ul><li>一致性：客户端的读操作要么读到最新的数据，要么读取失败</li><li>可用性：任何客户端的请求都能得到响应数据</li><li>分区容忍性：不同分区间的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉</li></ul><h2 id="以数据为中心的一致性">以数据为中心的一致性</h2><p>持续一致性：允许副本之间存在一定范围的偏差（数值、新旧程度、操作顺序）</p><p>顺序一致性：所有进程看到的操作顺序必须与程序员指定的操作顺序一致<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601915.png" alt=""></p><p>因果一致性：如果操作 A 导致了操作 B，则所有进程必须以相同的顺序观察到 A 和 B，但是并发操作可以按不同顺序处理<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601916.png" alt=""></p><p>操作分组一致性：将一组读写操作视为一个整体，确保它们在所有副本间的一致性</p><h2 id="以客户为中心的一致性">以客户为中心的一致性</h2><p>单调读：用户读取的数据版本只能是越来越新的，永远不会回退到旧版本</p><p>单调写：用户的写操作按顺序提交，后续写操作不会覆盖早期的写入</p><p>写后读一致性：读之前检查写操作集，用户写入的数据必须在后续读取中可见</p><p>读后写一致性：写之前检查读操作集，用户的写操作必须基于最近读取的数据，保证不会基于陈旧数据写入</p><h2 id="一致性协议">一致性协议</h2><p>主备份写–远程写：所有写操作都发送到主副本，由主副本执行写入并同步次副本<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601918.png" alt=""></p><p>主备份写–本地写：每个副本都可以充当主副本，但只处理本地写操作，之后，将更新同步到其他副本<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601919.png" alt=""></p><p>全副本写</p><ul><li>全复制写：所有副本同时接收写操作，并以相同的顺序执行</li><li>基于法定人数：写操作只需要发送到法定人数（Quorum）的副本集合，读操作从另一个法定人数集合中获取数据</li></ul><h1>容错性</h1><h2 id="故障">故障</h2><p>容错：允许系统部分组件失效，但系统仍可继续运行</p><p>可靠的系统</p><ul><li>可用性：系统在某一时间点可用，强调时刻</li><li>可靠性：长时间运行而不中断，强调时段</li><li>安全性：系统在出现故障后不会造成灾难</li><li>可维护性：系统能够快速检测并修复故障</li></ul><p>区分：故障导致错误，错误导致失败</p><ul><li>失败：系统未能提供预期的服务，用户视角</li><li>错误：系统内部状态偏离了其正确状态，软件视角</li><li>故障：系统组件中的缺陷或问题，底层视角</li></ul><p>故障类型</p><ul><li>暂时故障：一次性短暂故障，可能在不干预的情况下自动恢复</li><li>间歇故障：以周期性方式出现的故障，较难排查</li><li>持久故障：持续存在且需人工修复的故障，如芯片燃烧、磁盘损坏</li></ul><p>故障模式</p><ul><li>崩溃性：服务器停机（如操作系统进程错乱）</li><li>遗漏性：系统未能正确发送或接收消息（如网络传输错误）</li><li>定时性：系统未能按预期时间完成任务（如网络拥堵或阻塞过久）</li><li>响应性：系统返回错误的结果（如格式不符合）</li><li>随意性：又称为拜占庭故障，表现为系统的任意失效，随机返回结果，包括恶意行为</li></ul><h2 id="冗余掩盖故障">冗余掩盖故障</h2><p>信息冗余：通过附加信息来检测、定位或纠正错误<br>时间冗余：通过快速重复执行操作以掩盖临时故障<br>物理冗余：通过添加硬件组件来提供备用资源，应对硬件或软件故障</p><p>三倍模块冗余：通过在系统中复制三个独立的模块来执行相同的任务，并对其输出结果进行多数投票来决定最终的正确结果，如果一个模块出现故障（如硬件故障或计算错误），系统依然能够通过多数投票获得正确的结果，从而容忍单点故障</p><ul><li>通过复制和投票机制实现，设计和实现较为简单，可以快速检测故障</li><li>无法应对拜占庭故障，只是假设故障模块只会提供错误输出，而不是恶意或冲突的输出</li><li>可扩展性差，当需要容忍多个故障时，三倍的设计不足以满足需求</li></ul><h2 id="进程容错">进程容错</h2><p>通过创建多个进程副本构造容错进程组，把一个进程组作为一个单一抽象进程来处理，如果其中一个进程失败，可以让其他进程来接管它，从而实现故障掩盖</p><p>容错度：最多k个组件出现故障，系统仍能运行</p><ul><li>停止失效故障：进程组至少k+1个进程成员才能达到k容错度，也就是剩下一个可用的进程</li><li>随意性故障：进程组至少2k+1个进程成员才能达到k容错度，也就是说需要k+1个正确的输出在数量上多于k个错误的输出</li></ul><h2 id="故障检测">故障检测</h2><p>基于超时机制</p><ul><li>主动查询：进程 P 主动向进程 Q 发送探测消息并等待回复</li><li>被动等待：进程 P 被动地等待进程 Q 发来心跳消息</li><li>区分网络故障和节点故障：请邻居结点进行多方检查</li></ul><h2 id="RPC失效">RPC失效</h2><p>客户不能定位服务器：比如服务器关闭、服务端版本变化，客户端需要抛出异常，一定程度上损失透明性</p><p>丢失请求消息：客户端设置超时时间，未收到服务器响应时，重新发送请求，如果总是超时则认为网络错误</p><p>服务器崩溃：执行后崩溃，或者是执行前崩溃</p><ul><li>至少一次语义：不断尝试，直到得到应答</li><li>最多一次语义：立即放弃，并报告失败</li><li>不保证：RPC可能任意执行多次</li><li>恰好一次语义：理想情况，但无法实现</li></ul><p>丢失应答消息：客户端设置超时时间，未收到服务器响应时，重新发送请求</p><ul><li>幂等请求：重复执行不会造成任何影响</li><li>非幂等请求：同一个请求不能被执行两遍，需要通过标识符来确保服务器只处理一次</li></ul><p>客户崩溃：服务器上为该请求创建的进程或线程失去了与客户端的联系，服务器可能仍在处理该请求，造成资源浪费</p><ul><li>消灭：客户端根据日志向服务器通告杀死孤儿进程</li><li>再生：向服务器通知进入新周期，杀死旧周期与客户端相关的孤儿</li><li>温和再生：服务器会尝试找回client，如果找<br>不到拥有者则杀死孤儿</li><li>过期：每个RPC都被给定一个标准的时间量 T 来进行工作，超时后需要申请延期，否则会被终止</li></ul><h2 id="分组通信">分组通信</h2><p>接收方在成功接收到消息后返回ACK信号，如果发送方未在指定时间内收到ACK，判断消息丢失并重发，会引发ACK风暴<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601922.png" alt=""></p><p>接收方检测到消息丢失时主动发送NACK信号，其他接收方收到NACK就暂时抑制自己的NACK，发送方根据NACK重发丢失的消息，发送发不得不缓存大量分组以等待重发<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601923.png" alt=""></p><p>层次化多播，将所有接收进程分成若干小组，每个小组由一个协调者管理，协调者负责转发来自接收方的消息或来自其他协调者消息<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601924.png" alt=""></p><h2 id="分布式提交">分布式提交</h2><p>准备阶段</p><ol><li>协调者向所有参与者发送 “准备好提交吗？” 的投票请求（Vote-request）</li><li>参与者根据当前状态回复：同意提交（Vote-commit）或者拒绝提交（Vote-abort）</li></ol><p>提交阶段</p><ol><li>如果所有参与者都回复 Vote-commit，协调者发送 Global-commit，所有节点执行事务</li><li>如果有任一参与者回复 Vote-abort，协调者发送 Global-abort，所有节点中止事务</li></ol><p>失效情况</p><ul><li>参与者在 INIT 下超时，发送 Vote-abort，自己直接 Abort</li><li>协调者在 WAIT 下超时，发送 Global-abort，自己直接 Abort</li><li>参与者在 READY 下超时，获取其他参与者的状态<ul><li>都处于 READY 状态，继续等待协调者恢复</li><li>有一个处于 INIT 状态，自己 Abort</li><li>返回 COMMIT，执行提交</li><li>返回 ABORT，执行终止</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601925.png" alt=""></p><h2 id="恢复处理">恢复处理</h2><p>类别</p><ul><li>回退恢复：从错误状态返回到先前的正确状态</li><li>前进恢复：从某个状态开始执行到正确状态</li></ul><p>分布式快照 / 检查点：是分布式系统中每个进程的状态记录，以在系统故障时从检查点恢复</p><ul><li>独立检查点：每个进程创建检查点，但无法保证一致性，可能需要不断回滚到更早的检查点（多米诺效应）</li><li>协调检查点：检查点的创建由一个协调者统一触发，确保所有进程的状态是一致的，但检查点的开销较高，需要阻塞所有进程直到全局检查点完成</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601926.png" alt=""></p><p>消息日志：通过记录分布式系统中进程之间的消息传递历史，结合检查点，用于故障恢复的一种机制</p><ul><li>悲观日志：每条消息在应用之前记录到稳定存储，可能导致较高延时</li><li>乐观日志：每条消息在应用之后记录到稳定存储，可能会导致孤儿进程</li><li>因果日志：只记录与因果一致性相关的消息日志，但是实现很复杂</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601927.png" alt=""></p><h1>分布式协定协议</h1><p>分布式协定协议是为了解决分布式系统中在存在故障时，非故障进程能够在有限步骤内达成一致性的一类协议</p><h2 id="基于泛洪">基于泛洪</h2><p>基于泛洪的共识协议</p><ol><li>任一节点发现系统存在故障时，生成提案消息并通过泛洪传播</li><li>每个节点记录接收到的消息，转发给未收到该消息的节点</li><li>所有节点对消息的收敛状态达成一致</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601921.png" alt=""></p><h2 id="Paxos">Paxos</h2><p>节点角色：节点可以同时扮演多个角色</p><ul><li>提议者：提出要达成一致的值</li><li>接受者：决定是否接受提议者提出的值</li><li>学习者：获取被接受的值并更新</li></ul><p>执行轮次</p><ol><li>准备阶段<ol><li>提议者增加自己的轮次编号rnd，向所有接受者发送prepare消息，带上rnd</li><li>如果收到的rnd小于last_rnd，接受者则忽略请求</li><li>否则更新本地的last_rnd，回复一个promise消息，带有prev_rnd和prev_rnd对应的值v</li></ol></li><li>接受阶段<ol><li>提议者收到大多数的promise消息后，选择其中prev_rnd最大的消息对应的v，作为新提议的值</li><li>提议者发送accept消息，带上rnd和选定的值v</li><li>如果收到的rnd小于last_rnd，接受者则忽略请求，否则更新值为v</li></ol></li><li>学习阶段<ol><li>接受者将接受的值v广播给所有学习者</li><li>学习者一旦收到来自大多数接受者的值v，则更新自己的值</li></ol></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601920.png" alt=""></p><p>正确性</p><ul><li>决策主要是基于多数派</li><li>一旦一个值被多数派接收，那么后续都不会改变这个决定</li><li>不会同时存在两个不同的值被选为最终值</li></ul><p>局限性</p><ul><li>仅支持单个值的一致性</li><li>活锁问题：反复出现提议者，导致整个协议长时间没有结果或者崩溃</li><li>需要两轮消息传递才能确定一个值</li></ul><h2 id="RAFT">RAFT</h2><p>节点角色：</p><ul><li>跟随者：被动接受心跳或命令</li><li>候选者：在选举中自荐为领导者</li><li>领导者：负责处理客户端请求和日志复制</li></ul><p>工作流程</p><ol><li>候选者通过发送请求投票来选举，每次选举节点只能投票一次</li><li>如果某个候选者获取多数票，则成为领导者</li><li>领导者接收客户端命令，将其追加到日志中，同时将日志复制/覆盖到其他服务器</li><li>领导者按照分布式日志提交给每个节点的状态机执行，强行让整个系统恢复一致性</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601928.png" alt=""></p><p>局限性</p><ul><li>依赖于日志，如果磁盘损坏将会导致错误</li><li>领导者需要讲日志覆盖到全部节点，时间开销大</li><li>如果领导者崩溃，会导致选举新的领导者，期间无法处理客户端请求</li><li>领导者需要向全部节点发送心跳信号，来通知领导者有效</li></ul><h2 id="BFT">BFT</h2><p>BFT可以解决拜占庭协议问题，确保系统可以容忍最多f个恶意节点，前提是总节点数满足n &gt; 3f + 1</p><p>工作机制</p><ol><li>主节点提议一个值，向备份节点广播该值</li><li>备份节点接受主节点的提议，进一步广播消息与其他备份节点交换信息</li><li>每个备份节点都收到了来自其他节点的值，如果有超过 2f+1 个节点给出相同的值，则认为该值是最终协定值</li></ol><p>性质</p><ul><li>消息复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，随着节点数量增加，通信开销迅速增长</li><li>BFT假设系统是同步的，不适用现实情况</li></ul><h2 id="PBFT">PBFT</h2><p>工作流程</p><ol><li>请求阶段：客户端向主节点发送request消息</li><li>主节点收到请求后，广播pre-prepare消息给备份节点</li><li>备份节点收到请求后，广播PREPARE消息给其他备份节点</li><li>每个节点收集到2f + 1的PREPARE消息后，广播COMMIT消息给其他节点</li><li>当某个节点收到2f + 1条COMMIT消息后，认为请求已达成共识并将其执行，然欧向客户端发送REPLY消息</li><li>客户端在收到f + 1条一致的回复后，认为操作成功</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601929.png" alt=""></p><p>性质</p><ul><li>PBFT假设系统是异步的，利用标识符和多轮确认，可以处理消息延迟</li><li>消息复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>当主节点失效时，触发视图变更的过程需要额外的通信和时间成本</li></ul><h1>分布式文件系统</h1><p>属性</p><ul><li>文件系统的客户端、服务器、存储分散在不同物理机器上</li><li>各个部件通过网络互连</li><li>对于用户来讲，使用起来是就像是集中式文件系统</li><li>文件的访问时间应该满足QoS的要求</li><li>支持并发文件更新，支持多用户</li></ul><h2 id="NFS：基于客户-服务器">NFS：基于客户-服务器</h2><p>架构</p><ul><li>客户端通过VFS屏蔽本地和远程文件系统的差异</li><li>NFS客户端使用RPC来操作远程文件</li><li>NFS服务器提供其本地文件系统的视图</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601930.png" alt=""></p><p>优势：利用VFS支持异构系统，容易部署</p><p>局限性：访问速度受限于网络带宽，不适用于大规模集群环境</p><h2 id="HDFS：基于集群">HDFS：基于集群</h2><p>架构</p><ul><li>NameNode/主服务器：管理文件系统的元数据，将所有元数据存储在内存中，使用日志和检查点机制保证元数据一致性</li><li>DataNode/块服务器：存储实际数据块，定期向NameNode发送心跳信号报告状态</li><li>客户端：与NameNode/主服务器交互以获取元数据，与DataNode/块服务器交互以读写数据</li></ul><p>优势</p><ul><li>可靠性高：多副本存储实现数据可靠性</li><li>扩展性高：只需要修改主服务器就可以快速部署块服务器</li></ul><p>局限性：主服务器过载可能成为性能瓶颈</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601931.png" alt=""></p><h2 id="Ivy：对称式">Ivy：对称式</h2><p>架构</p><ul><li>基于P2P技术，无中央服务器，所有节点功能相同，任何节点都可以提供文件共享服务</li><li>利用分布式哈希表，实现节点间高效的数据定位</li><li>文件被分块存储，块通过 DHash 分散在不同的节点上</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/DistributedSystem/chapter3-10/202501011601932.png" alt=""></p><p>优势</p><ul><li>高可用性：自动应对节点故障</li><li>负载均衡：所有节点均可分担数据存储和访问请求</li><li>高扩展性：支持节点动态加入或退出</li></ul><p>局限性：节点间的协调和一致性维护需要额外开销</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>分布式系统课程笔记汇总</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://dasi.net.cn/posts/c625cd59/">https://dasi.net.cn/posts/c625cd59/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:55px"><h>作者</h><div class="post-copyright-cc-info"><h>Dasi</h></div></div><div class="post-copyright-c" style="display:inline-block;width:105px"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-12-30</h></div></div><div class="post-copyright-u" style="display:inline-block;width:105px"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-01-01</h></div></div><div class="post-copyright-c" style="display:inline-block;width:98px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post_share"><div class="social-share" data-image="/image/cover_distributedsystem.webp" data-sites="twitter,wechat,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.3" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js?v=1.1.3" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/5b80d779/" title="机器学习：绪论"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_machinelearning.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">机器学习：绪论</div><div class="content">定义、线性回归/分类，支持向量机，神经网络，决策树，线性降维，聚类，高斯混合模型，生成模型，集成学习，表示学习，推荐系统，异常检测，多模态学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/27689e44/" title="恢复系统"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_database.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">恢复系统</div><div class="content">故障类型、数据访问机制、基于日志恢复、缓冲区管理</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">分布式系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">分布式系统的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">分布式系统的四个目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">分布式系统的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F"><span class="toc-text">分布式计算系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F"><span class="toc-text">分布式信息系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%99%AE%E9%80%82%E7%B3%BB%E7%BB%9F"><span class="toc-text">分布式普适系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86"><span class="toc-text">区分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-text">样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-text">集中式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-text">非集中式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%BC%8F"><span class="toc-text">混合式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">中间件与体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%B2%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">自治体系结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-text">虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BD%9C%E7%94%A8"><span class="toc-text">虚拟化作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">虚拟化技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF"><span class="toc-text">云计算技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%BC%8F"><span class="toc-text">基本模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4"><span class="toc-text">服务器集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BB"><span class="toc-text">代码迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%81%E7%A7%BB"><span class="toc-text">基本迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%AE%B5%E5%A4%84%E7%90%86"><span class="toc-text">资源段处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%9E%84%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="toc-text">异构系统的迁移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">远程过程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E6%A6%82%E5%BF%B5"><span class="toc-text">RPC 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E7%B1%BB%E5%9E%8B"><span class="toc-text">RPC 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">面向消息的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9E%AC%E6%80%81%E9%80%9A%E4%BF%A1"><span class="toc-text">瞬态通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E9%80%9A%E4%BF%A1"><span class="toc-text">持久通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%B5%81%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">面向流的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E9%80%9A%E4%BF%A1"><span class="toc-text">多播通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">基于网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A6%86%E7%9B%96%E7%BD%91%E7%BB%9C%EF%BC%88Overlay%EF%BC%89"><span class="toc-text">基于覆盖网络（Overlay）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EGossip"><span class="toc-text">基于Gossip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">命名系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%B1%82%E6%AC%A1%E5%91%BD%E5%90%8D"><span class="toc-text">无层次命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E5%90%8D"><span class="toc-text">结构化命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-text">基于属性的命名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">同步性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F"><span class="toc-text">时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%97%B6%E9%97%B4%E5%8D%8F%E8%AE%AE"><span class="toc-text">网络时间协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Berkeley%E7%AE%97%E6%B3%95"><span class="toc-text">Berkeley算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lamport%E7%AE%97%E6%B3%95"><span class="toc-text">Lamport算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F"><span class="toc-text">向量时钟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE"><span class="toc-text">选举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-text">副本管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">以数据为中心的一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%AE%A2%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">以客户为中心的一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-text">一致性协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">容错性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C"><span class="toc-text">故障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E6%8E%A9%E7%9B%96%E6%95%85%E9%9A%9C"><span class="toc-text">冗余掩盖故障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%B9%E9%94%99"><span class="toc-text">进程容错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B"><span class="toc-text">故障检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E5%A4%B1%E6%95%88"><span class="toc-text">RPC失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E9%80%9A%E4%BF%A1"><span class="toc-text">分组通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-text">分布式提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%A4%84%E7%90%86"><span class="toc-text">恢复处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">分布式协定协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%9B%E6%B4%AA"><span class="toc-text">基于泛洪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paxos"><span class="toc-text">Paxos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAFT"><span class="toc-text">RAFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFT"><span class="toc-text">BFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PBFT"><span class="toc-text">PBFT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">分布式文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NFS%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">NFS：基于客户-服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDFS%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%9B%86%E7%BE%A4"><span class="toc-text">HDFS：基于集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ivy%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%BC%8F"><span class="toc-text">Ivy：对称式</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Dasi</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa-solid fa-arrow-up"></i><span>置顶</span></a><a class="rightMenu-item" href="javascript:rmf.copyPageUrl();"><i class="fa-solid fa-link"></i><span>复制链接</span></a></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.33"></script><script src="/pluginsSrc/instant.page/instantpage.js?v=5.2.0" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js?v=17.8.8"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js?v=4.0.7").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css?v=0.16.9"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js?v=0.16.9"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.dasi.net.cn/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"==typeof twikoo?setTimeout(t,0):getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.31").then(t)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/rightmenu.js?1"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/rightside.js?1"></script><script src="/js/sitetitle.js?1"></script><script id="click-show-text" src="/pluginsSrc/butterfly-extsrc/dist/click-show-text.min.js?v=1.1.3" data-mobile="false" data-text="d,a,s,i" data-fontsize="20px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/7bb01bb2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_algorithm.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" href="posts/7bb01bb2/" alt="">动态规划</a><div class="blog-slider__text">介绍了动态规划的原理，并用4个典例进行了详细分析，总结过后完成经典DP问题</div><a class="blog-slider__button" href="posts/7bb01bb2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/46ae7d29/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_AI.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-28</span><a class="blog-slider__title" href="posts/46ae7d29/" alt="">α-β剪枝</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/46ae7d29/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/f11dbe61/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_git.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-13</span><a class="blog-slider__title" href="posts/f11dbe61/" alt="">Git基本操作</a><div class="blog-slider__text">介绍git的基本操作以及对git指令的理解</div><a class="blog-slider__button" href="posts/f11dbe61/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/57fa915c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_algorithm.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-14</span><a class="blog-slider__title" href="posts/57fa915c/" alt="">排序</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/57fa915c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/55f40959/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_AI.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-21</span><a class="blog-slider__title" href="posts/55f40959/" alt="">谓词逻辑的归结反演</a><div class="blog-slider__text">如何利用python实现谓词逻辑的归结反演，详细分析了每个函数</div><a class="blog-slider__button" href="posts/55f40959/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/bbea855c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/cover_computernetwork.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-22</span><a class="blog-slider__title" href="posts/bbea855c/" alt="">运输层</a><div class="blog-slider__text">多路复用、多路分解、UDP和TCP、可靠数据传输原理、流水线模式和拥塞控制算法</div><a class="blog-slider__button" href="posts/bbea855c/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>