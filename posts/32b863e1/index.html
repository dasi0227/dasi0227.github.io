<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>MPI | Dasi's Blog</title><meta name="author" content="Dasi"><meta name="copyright" content="Dasi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MPI 程序结构、点对点通信、集合通信、派生数据类型、性能评估、梯形积分、奇偶换位排序、矩阵向量乘法"><meta property="og:type" content="article"><meta property="og:title" content="MPI"><meta property="og:url" content="https://dasi.plus/posts/32b863e1/"><meta property="og:site_name" content="Dasi&#39;s Blog"><meta property="og:description" content="MPI 程序结构、点对点通信、集合通信、派生数据类型、性能评估、梯形积分、奇偶换位排序、矩阵向量乘法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dasi.plus/image/parallel.png"><meta property="article:published_time" content="2025-02-06T08:39:40.000Z"><meta property="article:modified_time" content="2025-06-21T11:06:41.900Z"><meta property="article:author" content="Dasi"><meta property="article:tag" content="Parallel"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://dasi.plus/image/parallel.png"><link rel="shortcut icon" href="/image/avatar.webp"><link rel="canonical" href="https://dasi.plus/posts/32b863e1/"><link rel="preconnect"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=6.5.1"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.33" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:8,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:250,languages:{author:"作者: Dasi",link:"链接: ",source:"来源: Dasi's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.11.1",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!1,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MPI",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-06-21 19:06:41"}</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/tag.css?1"><link rel="stylesheet" href="/css/nav.css?1"><link rel="stylesheet" href="/css/homeArticle.css?1"><link rel="stylesheet" href="/css/category.css?1"><link rel="stylesheet" href="/css/cursor.css?1"><link rel="stylesheet" href="/css/background.css?1"><link rel="stylesheet" href="/css/rightmenu.css?1"><link rel="stylesheet" href="/css/copyright.css?1"><link rel="stylesheet" href="/css/archive.css?1"><link rel="stylesheet" href="/css/description.css?1"><link rel="stylesheet" href="/css/post.css?1"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",(()=>{o()}))})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/image/parallel.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Dasi's Blog"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp"><span class="site-name">Dasi's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-star"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-globe"></i> <span>旅游</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MPI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-06T08:39:40.000Z" title="发表于 2025-02-06 16:39:40">2025-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MPI"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h2 id="1-MPI-程序">1. MPI 程序</h2><h3 id="1-1-概述">1.1 概述</h3><p><strong>消息传递接口（Message-Passing Interface, MPI）<strong>是一组 C 函数库，而不是一种新的编程语言，主要用于</strong>分布式内存系统中进程之间的通信</strong>，通过<strong>显式地发送和接收消息</strong>来实现数据交换</p><ol><li><p>编写 MPI 程序时引入头文件，包含 MPI 标准接口的函数原型、常量和类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>利用封装好的 mpicc 编译器生成可执行文件，自动将 MPI 头文件路径加入到编译器的搜索路径，并将 MPI 库路径加入到链接命令中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicc -o main main.c</span><br></pre></td></tr></table></figure></li><li><p>启动并行程序，手动指定节点数量并启动多个 MPI 进程，同时为每个进程建立通信环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -n 4 ./main</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-框架">1.2 框架</h3><table><thead><tr><th>过程</th><th>功能</th><th>MPI 函数</th></tr></thead><tbody><tr><td>1</td><td>初始化 MPI 环境</td><td>MPI_Init、MPI_Abort</td></tr><tr><td>2</td><td>获取当前进程的编号和总进程数量</td><td>MPI_Comm_rank、MPI_Comm_size</td></tr><tr><td>3</td><td>调用 MPI 函数执行并行任务</td><td>点对点通信：MPI_Send、MPI_Recv<br>集合通信：MPI_Bcast、MPI_Scatter、MPI_Gather、MPI_Reduce</td></tr><tr><td>4</td><td>设置同步路障</td><td>MPI_Barrier</td></tr><tr><td>5</td><td>主进程输出汇总结果</td><td>无</td></tr><tr><td>6</td><td>清理 MPI 环境</td><td>MPI_Finalize</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 MPI 环境</span></span><br><span class="line">    <span class="type">int</span> err = MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="keyword">if</span> (err != MPI_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;MPI_Init failed\n&quot;</span>);</span><br><span class="line">        MPI_Abort(MPI_COMM_WORLD, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取当前进程的编号和总进程数量</span></span><br><span class="line">	  <span class="type">int</span> rank, size, err;</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 并行任务区</span></span><br><span class="line">  	...</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 同步路障</span></span><br><span class="line">    MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 5. 主进程输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理 MPI 环境</span></span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-通信子">1.3 通信子</h3><p><strong>通信子（communicator）<strong>是 MPI 中描述</strong>进程组的通信上下文</strong>的对象，是 MPI 中<strong>管理和组织进程通信的基本单位</strong></p><ul><li><strong>进程组</strong>：明确了参与该通信子中通信的所有进程，只有同一通信子里的进程才能互相发送／接收消息</li><li><strong>通信上下文</strong>：保证消息隔离，不同通信子之间即使使用相同的消息标签、数据类型，也不会相互干扰</li><li><strong>MPI_COMM_WORLD</strong>：包含所有进程的全局通信子，是默认通信子</li><li><strong>MPI_Comm</strong>：通信子类型</li></ul><p>通信子操作</p><ul><li><p>复制已有的通信子，<strong>拥有相同的进程组，但会创建新的上下文</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_dup</span><span class="params">(MPI_Comm comm, MPI_Comm *newcomm)</span>;</span><br></pre></td></tr></table></figure></li><li><p>将一个通信子划分为多个新的通信子，每个通信子有不同的上下文，其中 color 是划分依据，key 是排序依据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_split</span><span class="params">(MPI_Comm comm, <span class="type">int</span> color, <span class="type">int</span> key, MPI_Comm *newcomm)</span>;</span><br></pre></td></tr></table></figure></li><li><p>基于指定的进程组创建一个新的通信子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_create</span><span class="params">(MPI_Comm comm, MPI_Group group, MPI_Comm *newcomm)</span>;</span><br></pre></td></tr></table></figure></li><li><p>释放通信子占用的资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_free</span><span class="params">(MPI_Comm *comm)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取指定通信子中包含的进程总数，存储到 size 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *size)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取当前进程在指定通信子中的编号，存储到 rank 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *rank)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-点对点通信">2. 点对点通信</h2><h3 id="2-1-特点">2.1 特点</h3><p>点对点通信的通信双方都是单个进程，是一对一的通信模式</p><ul><li><strong>进程悬挂</strong><ul><li>阻塞发送：发送方会阻塞后续执行，直到 MPI 确保数据已经复制到内部缓冲区或真正传输并被接收方接收</li><li>阻塞接收：接收方会阻塞后续执行，直到收到匹配的消息并把数据拷贝进缓冲区</li></ul></li><li><strong>有序性/不可超越性</strong>：对同一源–目标对的多次发送，MPI 保证接收端按发送顺序接收，无须额外同步</li><li>接收原则：每条消息都携带<strong>三要素 (source, tag, comm)</strong>，只有三者全部匹配才算“命中”并交付接收缓冲区</li></ul><h3 id="2-2-MPI-Send">2.2 MPI_Send</h3><p><strong>发送方发送消息传递数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Send</span><span class="params">(</span></span><br><span class="line"><span class="params">  	<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, </span></span><br><span class="line"><span class="params">  	<span class="type">int</span> dest, <span class="type">int</span> tag, MPI_Comm comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>buf：指向待发送数据的起始地址</li><li>count：待发送数据的元素数量</li><li>datatype：待发送数据的数据类型</li><li>dest：接收进程在指定通信子中的编号</li><li>tag：发送消息的标签，必须指定一个非负整数</li><li>comm：指定通信上下文的通信子</li></ul><h3 id="2-3-MPI-Recv">2.3 MPI_Recv</h3><p><strong>接收方接收消息获取数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Recv</span><span class="params">(</span></span><br><span class="line"><span class="params">  	<span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, </span></span><br><span class="line"><span class="params">  	<span class="type">int</span> source, <span class="type">int</span> tag, MPI_Comm comm, </span></span><br><span class="line"><span class="params">  	MPI_Status *status</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>buf：指向接收缓冲区的起始地址，长度至少为 count</li><li>count：最多可接收元素的个数</li><li>datatype：预期接收的数据类型</li><li>source：发送进程在指定通信子中的编号，可以使用通配符 <code>MPI_ANY_SOURCE</code></li><li>tag：要接收消息的标签</li><li>comm：指定通信上下文的通信子，可以使用通配符 <code>MPI_ANY_TAG</code></li><li>status：消息的状态对象<ul><li>status.MPI_SOURCE：实际发送者 rank</li><li>status.MPI_TAG：实际接收的标签</li><li><code>MPI_Get_count(&amp;status, datatype, &amp;num)</code>：实际收到的元素数存到 num 中</li></ul></li></ul><h3 id="2-4-MPI-Sendrecv">2.4 MPI_Sendrecv</h3><p>将进程的发送消息和接收消息操作合并为一条调用，可以避免死锁情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Sendrecv</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">int</span> sendcount, MPI_Datatype sendtype,</span></span><br><span class="line"><span class="params">  	<span class="type">int</span> dest, <span class="type">int</span> sendtag,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *recvbuf, <span class="type">int</span> recvcount, MPI_Datatype recvtype, <span class="type">int</span> source, <span class="type">int</span> recvtag,</span></span><br><span class="line"><span class="params">    MPI_Comm comm, MPI_Status *status</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>sendbuf：指向本进程待发送数据起始地址</li><li>sendcount：要发送的元素数量</li><li>sendtype：发送数据的 MPI 类型</li><li>dest：目标进程在 comm 中的 rank</li><li>sendtag：发送消息的标签</li><li>recvbuf：指向本进程接收缓冲区起始地址</li><li>recvcount：接收缓冲区能容纳的最大元素数量</li><li>recvtype：接收数据的 MPI 类型（应与发送端匹配）</li><li>source：指定接收哪一 rank 的消息；可用 MPI_ANY_SOURCE</li><li>recvtag：指定要接收的标签；可用 MPI_ANY_TAG</li><li>comm：通信子，决定参与点对点的进程组</li><li>status：输出参数，调用完成后可通过它获取实际接收的源、标签及元素数量</li></ul><blockquote><p>可以传递 MPI_STATUS_IGNORE</p></blockquote><h3 id="2-5-归约">2.5 归约</h3><p>归约指的是把<strong>每个进程产生的多个局部值用某种结合性运算“汇总”成一个全局结果</strong>，在点对点通信中有两种模式</p><table><thead><tr><th>归约模式</th><th>说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>单点归约</td><td>所有非 0 进程将本地结果发送到主进程，主进程按顺序收到后逐一进行处理</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord mathnormal">p</span></span></span></span></td></tr><tr><td>树形归约</td><td>把 p 个进程看作完全二叉树的叶子，按层两两配对归约，每轮进程数减半，直到根节点</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>p</mi></mrow><annotation encoding="application/x-tex">\log_2 p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9386em;vertical-align:-.2441em"></span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.207em"><span style="top:-2.4559em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2441em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">p</span></span></span></span></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (step &lt; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rank % (<span class="number">2</span>*step) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 收下游配对进程的数据</span></span><br><span class="line">        <span class="type">int</span> src = rank + step;</span><br><span class="line">        <span class="keyword">if</span> (src &lt; p) &#123;</span><br><span class="line">            MPI_Recv(&amp;tmp, <span class="number">1</span>, MPI_DOUBLE, src, tag, comm, MPI_STATUS_IGNORE);</span><br><span class="line">            local = local ⊕ tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank % (<span class="number">2</span>*step) == step) &#123;</span><br><span class="line">        <span class="comment">// 发送到上游配对进程，然后退出循环</span></span><br><span class="line">        <span class="type">int</span> dst = rank - step;</span><br><span class="line">        MPI_Send(&amp;local, <span class="number">1</span>, MPI_DOUBLE, dst, tag, comm);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    step &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Parallel/202502272001125.png" alt=""></p><h2 id="3-集合通信">3. 集合通信</h2><h3 id="3-1-特点">3.1 特点</h3><p>集合通信指的是一个通信子内的所有进程都要参与通信，无须显式指定目标或源</p><ul><li><strong>隐式同步</strong>：大多数阻塞型集合通信，会在内部完成必要的同步，调用返回时保证数据已在所有进程就位</li><li><strong>语义丰富</strong>：适合进行<strong>分发、收集、归约、广播、同步</strong>等操作</li><li><strong>算法自优化</strong>：MPI 实现通常会根据消息大小、进程数、底层网络拓扑自动选择最优算法</li></ul><h3 id="3-2-MPI-Bcast">3.2 MPI_Bcast</h3><p><strong>根进程广播数据到通信子内的进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Bcast</span><span class="params">(</span></span><br><span class="line"><span class="params">  	<span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, </span></span><br><span class="line"><span class="params">  	<span class="type">int</span> root, MPI_Comm comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>buf：广播方指向待广播数据的起始地址，接收方指向接收数据缓冲区的起始地址</li><li>count：每个进程要发送／接收的元素数量</li><li>datatype：元素的数据类型</li><li>root：广播进程在指定通信子的编号</li><li>comm：指定参与广播的进程组</li></ul><h3 id="3-3-MPI-Scatter">3.3 MPI_Scatter</h3><p><strong>根进程将发送缓冲区中的数据，按进程编号顺序以等块方式分发到通信子内所有进程的接收缓冲区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Scatter</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">int</span> sendcount, MPI_Datatype sendtype,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *recvbuf,       <span class="type">int</span> recvcount, MPI_Datatype recvtype,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> root, MPI_Comm comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>sendbuf：根进程的发送缓冲区起始地址，其他进程填 NULL</li><li>sendcount：根进程向每个进程发送的元素数量</li><li>sendtype：发送数据的类型</li><li>recvbuf：各进程用于接收数据的缓冲区起始地址</li><li>recvcount：每个进程接收的元素数量</li><li>recvtype：接收数据的类型</li><li>root：指定分发数据的根进程 rank</li><li>comm：通信子，指定参与分发的进程组</li></ul><h3 id="3-4-MPI-Gather">3.4 MPI_Gather</h3><p><strong>将通信子内所有进程的发送缓冲区中的数据，按进程编号顺序，收集并拼接到根进程的接收缓冲区中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Gather</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">int</span> sendcount, MPI_Datatype sendtype,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *recvbuf,       <span class="type">int</span> recvcount, MPI_Datatype recvtype,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> root, MPI_Comm comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>sendbuf：各进程本地要发送的数据缓冲区起始地址</li><li>sendcount：每个进程发送的元素数量</li><li>sendtype：发送数据的类型</li><li>recvbuf：根进程用于接收所有进程数据的缓冲区起始地址，非根进程填 NULL</li><li>recvcount：根进程为每个发送进程预留的接收元素数量</li><li>recvtype：接收数据的类型</li><li>root：汇集数据的根进程 rank</li><li>comm：通信子，指定参与收集的进程组</li></ul><h3 id="3-5-MPI-Allgather">3.5 MPI_Allgather</h3><p><strong>将通信子内所有进程的发送缓冲区中的数据，按进程编号顺序，收集并拼接到所有进程的接收缓冲区中</strong></p><blockquote><p>说白了就是每个进程都可以拿到聚集结果，而不单单是根进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Allgather</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">int</span> sendcount, MPI_Datatype sendtype,</span></span><br><span class="line"><span class="params">    <span class="type">void</span>       *recvbuf, <span class="type">int</span> recvcount, MPI_Datatype recvtype,</span></span><br><span class="line"><span class="params">    MPI_Comm    comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>sendbuf：各进程本地要发送的数据缓冲区起始地址</li><li>sendcount：每个进程发送的元素数量</li><li>sendtype：发送数据的类型</li><li>recvbuf：根进程用于接收所有进程数据的缓冲区起始地址，非根进程填 NULL</li><li>recvcount：根进程为每个发送进程预留的接收元素数量</li><li>recvtype：接收数据的类型</li><li>root：汇集数据的根进程 rank</li><li>comm：通信子，指定参与收集的进程组</li></ul><h3 id="3-6-MPI-Reduce">3.6 MPI_Reduce</h3><p><strong>对通信子内所有进程的发送缓冲区中的数据，使用指定的归约操作进行聚合，并将最终结果存放在根进程的接收缓冲区中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">void</span> *recvbuf, <span class="type">int</span> count, MPI_Datatype datatype, </span></span><br><span class="line"><span class="params">  	MPI_Op op,</span></span><br><span class="line"><span class="params">  	<span class="type">int</span> root, MPI_Comm comm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>sendbuf：各进程要归约的本地数据缓冲区起始地址</li><li>recvbuf：根进程用于接收归约结果的缓冲区起始地址；非根进程可填 NULL</li><li>count：要归约的元素数量，不是归约结果的元素数量</li><li>datatype：数据类型</li><li>op：归约操作符</li><li>root：接收和保存全局结果的根进程 rank</li><li>comm：通信子，指定参与归约的进程组</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Parallel/202502272001126.png" alt=""></p><p>注意</p><ul><li>MPI_Reduce 是对长度为 N 的缓冲区做的是“按下标”逐元素归约，而不是扁平化操作</li><li>所有进程必须调用相同的集合通信函数，除了 sendbuf 参数外，其他参数也应该是相同的</li><li>不允许使用同一个缓冲区同时是输入缓冲和输出缓冲，这样的结果是不可预测的</li></ul><h2 id="4-派生数据类型">4. 派生数据类型</h2><h3 id="4-1-定义">4.1 定义</h3><p>派生数据类型允许用户自定义与原生类型不同的的<strong>内存布局</strong>，以便在一次通信调用中发送／接收非连续或结构化的数据块</p><ul><li>MPI 通信的成本是较大的，与其将基础类型分多次通信，不如将多个基础数据组合成一个派生数据类型，只需一次通信调用，就能把各段数据打包发送，显著<strong>减少多次调用带来的启动延迟</strong></li><li>如果同一个布局会被多次发送／接收，提前创建并多次重用派生类型，可以把<strong>创建／提交的成本摊薄，提高长期性能</strong></li><li>对于<strong>非常复杂的非连续模式</strong>，派生类型通常能带来更好的可维护性和性能，但是相对简单的非连续模式可能达不到好的效果，甚至会降低性能</li></ul><p>使用流程</p><ol><li>创建：调用相应的 <code>MPI_Type_*</code>函数，描述布局</li><li>提交：调用 <code>MPI_Type_commit(&amp;newtype)</code> 让 MPI 知道新类型的含义</li><li>使用：在 MPI 通信函数中的 datatype 参数中使用</li><li>释放：调用 <code>MPI_Type_free(&amp;newtype)</code> 释放新类型占用的资源</li></ol><h3 id="4-2-MPI-Type-contiguous">4.2 MPI_Type_contiguous</h3><p><strong>将若干个连续的元素合并成一个新的派生类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Type_contiguous</span><span class="params">(<span class="type">int</span> count, MPI_Datatype oldtype, MPI_Datatype *newtype)</span>;</span><br></pre></td></tr></table></figure><ul><li>count：要合并的元素个数</li><li>oldtype：已有的基础类型或已提交的派生类型</li><li>newtype：输出的新类型句柄</li></ul><h3 id="4-3-MPI-Type-create-struct">4.3 MPI_Type_create_struct</h3><p><strong>将若干块不同类型的数据组合成一个新的派生类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Type_create_struct</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">int</span> blocklens[],</span></span><br><span class="line"><span class="params">    <span class="type">const</span> MPI_Aint displs[],</span></span><br><span class="line"><span class="params">    <span class="type">const</span> MPI_Datatype types[],</span></span><br><span class="line"><span class="params">    MPI_Datatype *newtype</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>count：块的数量</li><li>blocklens[i]：第 i 块中元素的个数</li><li>displs[i]：第 i 块相对于结构体起始地址的字节偏移</li><li>types[i]：第 i 块的元素 MPI 类型</li><li>newtype：输出的新类型句柄</li></ul><p>构建流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Particle</span> &#123;</span></span><br><span class="line">		<span class="type">double</span> 	pos[<span class="number">3</span>];</span><br><span class="line">		<span class="type">int</span>			id;</span><br><span class="line">		<span class="type">float</span> 	mass;</span><br><span class="line">&#125; particle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 确定块数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 确定每块的元素数量</span></span><br><span class="line"><span class="type">int</span> blocklens[] = &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 确定每块的数据类型</span></span><br><span class="line">MPI_Datatype types[] = &#123; MPI_DOUBLE, MPI_INT, MPI_FLOAT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取每块的地址</span></span><br><span class="line">MPI_Aint base, addr_pos, addr_id, addr_mass;</span><br><span class="line">MPI_Get_address(&amp;particle,       &amp;base);</span><br><span class="line">MPI_Get_address(&amp;particle.pos,   &amp;addr_pos);</span><br><span class="line">MPI_Get_address(&amp;particle.id,    &amp;addr_id);</span><br><span class="line">MPI_Get_address(&amp;particle.mass,  &amp;addr_mass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 计算每块的偏移</span></span><br><span class="line">displs[<span class="number">0</span>] = addr_pos - base;</span><br><span class="line">displs[<span class="number">1</span>] = addr_id  - base;</span><br><span class="line">displs[<span class="number">2</span>] = addr_mass- base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建并提交类型</span></span><br><span class="line">MPI_Datatype MPI_PARTICLE;</span><br><span class="line">MPI_Type_create_struct(count, blocklens, displs, types, &amp;MPI_PARTICLE);</span><br><span class="line">MPI_Type_commit(&amp;MPI_PARTICLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// … 在通信里使用 MPI_PARTICLE …</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 用完释放</span></span><br><span class="line">MPI_Type_free(&amp;MPI_PARTICLE);</span><br></pre></td></tr></table></figure><h2 id="5-性能评估">5. 性能评估</h2><h3 id="5-1-计时">5.1 计时</h3><table><thead><tr><th><strong>时间类型</strong></th><th><strong>定义</strong></th></tr></thead><tbody><tr><td>程序运行时间</td><td>从程序<strong>开始运行到结束运行</strong>所耗费的墙钟时间，包含初始化、通信、I/O 和计算等各部分的总耗时</td></tr><tr><td>CPU 时间</td><td>程序实际<strong>占用 CPU 执行指令</strong>的时间，不包括等待 I/O 或其他阻塞操作的停用时间</td></tr><tr><td>并行计算时间</td><td>所有进程<strong>执行并行计算部分</strong>所花费的时间，以最慢进程的耗时为准</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 声明变量</span></span><br><span class="line"><span class="type">double</span> t0, t1;</span><br><span class="line"><span class="comment">// 1. 确保所有进程的开始时间相同</span></span><br><span class="line">MPI_Barrier(comm); </span><br><span class="line"><span class="comment">// 2. 记录开始时间</span></span><br><span class="line"><span class="type">double</span> t0 = MPI_Wtime();</span><br><span class="line"><span class="comment">// ... 任务执行...</span></span><br><span class="line"><span class="comment">// 3. 确保所有进程的结束时间相同</span></span><br><span class="line">MPI_Barrier(comm); </span><br><span class="line"><span class="comment">// 4. 记录结束时间</span></span><br><span class="line"><span class="type">double</span> t1 = MPI_Wtime();</span><br><span class="line"><span class="comment">// 5. 只有主进程负责输出</span></span><br><span class="line"><span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Elapsed = %fs\n&quot;</span>, t1 - t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于操作系统的不可预知性，同一段程序的运行时间不可能每次都完全一样</p></blockquote><h3 id="5-2-问题规模-vs-进程数量">5.2 问题规模 vs 进程数量</h3><ul><li><p>问题规模不变，随着进程数量增加，运行时间逐渐下降：更多进程意味着更强的计算能力，展现了强扩展性</p></li><li><p>进程数量不变，随着问题规模增加，运行时间逐渐上升：更多数据意味着更多计算</p></li><li><p>当问题规模较小且进程数量较少的时候，或者问题规模较大且进程数量较多的时候，增加进程数量可以显著降低运行时间：每个进程拿到的计算适中，并行收益大于开销成本</p></li><li><p>当问题规模较小且进程数量较多的时候，增加进程数量不会使得运行时间显著下降，甚至会导致运行时间提升：每个进程拿到的计算太少，导致开销成本大于并行收益</p></li><li><p>当问题规模较大且进程数量较多的时候，近似线性效率：增加进程数量可以适配增大问题规模，展现了弱扩展性</p></li><li><p>当问题规模较小且进程数量较多的时候，效率严重下降：并行粒度过细，单位进程的有效工作时间微乎其微</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Parallel/202502272001131.png" alt=""></p><h2 id="6-实践">6. 实践</h2><h3 id="6-1-梯形积分法">6.1 梯形积分法</h3><h4 id="6-1-1-公式推导">6.1.1 公式推导</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≈</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mn>2</mn><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>+</mo><mi>h</mi><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo fence="true" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \int_a^b f(x)\,\mathrm{d}x &amp;\approx \frac{h}{2}\Bigl[f(x_0)+f(x_1)\Bigr]+\cdots+\frac{h}{2}\Bigl[f(x_{n-1})+f(x_n)\Bigr]\\ &amp;= \frac{h}{2}\Bigl[f(x_0)+2f(x_1)+\cdots+2f(x_{n-1})+f(x_n)\Bigr]\\ &amp;= \frac{h}{2}\Bigl[f(x_0) + f(x_n)\Bigr] + h\Bigl[f(x_1) + \cdots + f(x_{n-1})\Bigr] \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.5258em;vertical-align:-3.5129em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.0129em"><span style="top:-6.0129em"><span class="pstrut" style="height:3.599em"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:.44445em;position:relative;top:-.0011em">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.599em"><span style="top:-1.7881em;margin-left:-.4445em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.8129em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9119em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.4295em"><span class="pstrut" style="height:3.599em"></span><span class="mord"></span></span><span style="top:-1.0721em"><span class="pstrut" style="height:3.599em"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5129em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.0129em"><span style="top:-6.0129em"><span class="pstrut" style="height:3.599em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen"><span class="delimsizing size2">[</span></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="delimsizing size2">]</span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen"><span class="delimsizing size2">[</span></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="delimsizing size2">]</span></span></span></span><span style="top:-3.4295em"><span class="pstrut" style="height:3.599em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen"><span class="delimsizing size2">[</span></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="delimsizing size2">]</span></span></span></span><span style="top:-1.0721em"><span class="pstrut" style="height:3.599em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen"><span class="delimsizing size2">[</span></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="delimsizing size2">]</span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal">h</span><span class="mopen"><span class="delimsizing size2">[</span></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="delimsizing size2">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5129em"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Parallel/202502272001123.png" alt=""></p><h4 id="6-1-2-串行算法">6.1.2 串行算法</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = (b-a) / n</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">  x_i = a + i * h</span><br><span class="line">  x_j = a + (i + 1) * h</span><br><span class="line">  y += f(x_i) + f(x_j)</span><br><span class="line">&#125;</span><br><span class="line">y = h / 2 * y</span><br></pre></td></tr></table></figure><h4 id="6-1-3-并行算法">6.1.3 并行算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，不关注如何实现</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  	<span class="comment">// 1. 初始化环境</span></span><br><span class="line">    <span class="type">int</span> err = MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="keyword">if</span> (err != MPI_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;MPI_Init failed\n&quot;</span>);</span><br><span class="line">        MPI_Abort(MPI_COMM_WORLD, err);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 2. 获取环境信息</span></span><br><span class="line">  	<span class="type">int</span> size, rank;</span><br><span class="line">  	MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">  	MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 3. 初始化数据，假设 f(x)=x^2</span></span><br><span class="line">  	<span class="type">double</span> a = <span class="number">1</span>, b = <span class="number">10</span>;</span><br><span class="line">  	<span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">  	<span class="type">double</span> h = (b - a) / n;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 4. 每个进程负责的区间</span></span><br><span class="line">  	<span class="type">int</span> base = n / size;</span><br><span class="line">  	<span class="type">int</span> rest = n % size;</span><br><span class="line">    <span class="type">int</span> local_n = base + (rank &lt; rest ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  	<span class="type">int</span> start 	= rank * base + (rank &lt; rest ? rank : rest);</span><br><span class="line">  	<span class="type">int</span> end 		= start + local_n;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 5. 每个进程负责的计算</span></span><br><span class="line">  	<span class="type">double</span> x_i = <span class="number">0.0</span>, x_j = <span class="number">0.0</span>, local_y = <span class="number">0.0</span>;</span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">      	x_i = a + i * h;</span><br><span class="line">      	x_j = a + (i + <span class="number">1</span>) * h;</span><br><span class="line">      	local_y += f(x_i) + f(x_j);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 6. 集合通信</span></span><br><span class="line">  	<span class="type">double</span> y = <span class="number">0.0</span>;</span><br><span class="line">  	MPI_Reduce(&amp;local_y, &amp;y, <span class="number">1</span>, MPI_DOUBLE, MPI_SUM, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">  	y *= h * <span class="number">0.5</span>;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 7. 主进程负责输出</span></span><br><span class="line">  	<span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="built_in">printf</span>(<span class="string">&quot;Integral from %g to %g of f(x)=x^2 ≈ %.6f\n&quot;</span>, a, b, y);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 8. 清理环境</span></span><br><span class="line">  	MPI_Finalize();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-并行奇偶换位排序算法">6.2 并行奇偶换位排序算法</h3><h4 id="6-2-1-原理">6.2.1 原理</h4><p>反复交替执行两个阶段来排序，<strong>每个阶段内的【比较交换】操作彼此独立</strong>，因此可以并行执行，同时可以确保如果序列有 n 个键值，那么经过 n 个阶段后，序列一定可以排好序</p><div class="note success flat"><p>起始：5，9，4，3<br>偶数：5，9，3，4<br>奇数：5，3，9，4<br>偶数：3，5，4，9<br>奇数：3，4，5，9</p></div><h4 id="6-2-2-串行算法">6.2.2 串行算法</h4><ul><li>奇数阶段：比较序列中索引为奇数的元素与其后面的相邻元素，如果前者大于后者，则交换</li><li>偶数阶段：比较序列中索引为偶数的元素与其后面的相邻元素，如果前者大于后者，则交换</li></ul><h4 id="6-2-3-并行算法">6.2.3 并行算法</h4><ol><li>数据分发：主进程通过 MPI_Scatter 将待排序数组分发给各个进程</li><li>偶数阶段<ul><li>如果进程号为偶数，则发送本地数组到右侧进程</li><li>如果进程号为奇数，则发送本地数组到左侧进程</li></ul></li><li>奇数阶段<ul><li>如果进程号为奇数，则发送本地数组到右侧进程</li><li>如果进程号为偶数，则发送本地数组到左侧进程</li></ul></li><li>合并数据：将本地数组和接收数组进行排序，小编号进程保留小半部分，大编号进程保留大半部分</li><li>数据汇总：主进程通过 MPI_Gather 得到全局排序数组</li></ol><blockquote><p>第一个进程可能没有左侧进程，最后一个进程可能没有右侧进程，可以设置 MPI_PROC_NULL 来避免无效通信，也可以直接跳过</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并数组并进行排序，不关注如何实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *out, <span class="type">int</span> length)</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 初始化数组，不关注如何实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> length)</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  	<span class="comment">// 1. 初始化环境</span></span><br><span class="line">    <span class="type">int</span> err = MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="keyword">if</span> (err != MPI_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;MPI_Init failed\n&quot;</span>);</span><br><span class="line">        MPI_Abort(MPI_COMM_WORLD, err);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 2. 获取环境信息</span></span><br><span class="line">  	<span class="type">int</span> size, rank;</span><br><span class="line">  	MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">  	MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 3. 初始化数据（不考虑不可整除）</span></span><br><span class="line">  	<span class="type">int</span> n = <span class="number">1000</span>;</span><br><span class="line">  	<span class="type">int</span> local_n = n / size;</span><br><span class="line">  	<span class="type">int</span> *x 			= <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">  	<span class="type">int</span> *local_x = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * local_n);</span><br><span class="line">  	<span class="type">int</span> *local_y = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * local_n);</span><br><span class="line">  	<span class="type">int</span> *local_z = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * local_n * <span class="number">2</span>);</span><br><span class="line">  	init(x, n);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 4. 分发数据</span></span><br><span class="line">    MPI_Scatter(</span><br><span class="line">      x,       local_n, MPI_INT,</span><br><span class="line">      local_x, local_n, MPI_INT, </span><br><span class="line">      <span class="number">0</span>, MPI_COMM_WORLD</span><br><span class="line">    );</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 5. 奇偶交换排序</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> phase = <span class="number">0</span>; phase &lt; size; phase++) &#123;</span><br><span class="line">      	<span class="comment">// 5.1 寻找发送对象</span></span><br><span class="line">      	<span class="type">int</span> partner;</span><br><span class="line">      	<span class="comment">// 偶数阶段</span></span><br><span class="line">      	<span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          	partner = rank % <span class="number">2</span> == <span class="number">0</span> ? rank + <span class="number">1</span> : rank - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 奇数阶段</span></span><br><span class="line">      	<span class="keyword">if</span> (phase % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">          	partner = rank % <span class="number">2</span> != <span class="number">0</span> ? rank + <span class="number">1</span> : rank - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 5.2 发送本地数组，进行合并排序</span></span><br><span class="line">      	<span class="keyword">if</span> (partner &gt;= <span class="number">0</span> &amp;&amp; partner &lt; size) &#123;</span><br><span class="line">          	MPI_Sendrecv(</span><br><span class="line">            	local_x, local_n, MPI_INT, partner, <span class="number">0</span>,</span><br><span class="line">              local_y, local_n, MPI_INT, partner, <span class="number">0</span>,</span><br><span class="line">             	MPI_COMM_WORLD, MPI_STATUS_IGNORE</span><br><span class="line">            );</span><br><span class="line">          	merge_sort(local_x, local_y, local_z, local_n);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 5.3 更新本地数组</span></span><br><span class="line">        <span class="keyword">if</span> (rank &lt; partner) &#123;</span><br><span class="line">						<span class="built_in">memcpy</span>(local_x, local_z, local_n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span> (rank &gt; partner) &#123;</span><br><span class="line">          	<span class="built_in">memcpy</span>(local_x, local_z + local_n, local_n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 6. 集合通信</span></span><br><span class="line">  	MPI_Gather(</span><br><span class="line">      	local_x, local_n, MPI_INT,</span><br><span class="line">      	x, 			 local_n, MPI_INT,</span><br><span class="line">      	<span class="number">0</span>, MPI_COMM_WORLD, </span><br><span class="line">    );</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 7. 主进程负责输出</span></span><br><span class="line">  	<span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sorted array:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 8. 清理环境</span></span><br><span class="line">  	MPI_Finalize();</span><br><span class="line">  	<span class="built_in">free</span>(x);</span><br><span class="line">  	<span class="built_in">free</span>(local_x);</span><br><span class="line">  	<span class="built_in">free</span>(local_y);</span><br><span class="line">  	<span class="built_in">free</span>(local_z);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-矩阵向量乘法">6.3 矩阵向量乘法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Parallel/202502272001129.png" alt=""></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MPI</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://dasi.plus/posts/32b863e1/">https://dasi.plus/posts/32b863e1/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display:inline-block;width:55px"><h>作者</h><div class="post-copyright-cc-info"><h>Dasi</h></div></div><div class="post-copyright-c" style="display:inline-block;width:105px"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-02-06</h></div></div><div class="post-copyright-u" style="display:inline-block;width:105px"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-06-21</h></div></div><div class="post-copyright-c" style="display:inline-block;width:98px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Parallel/">Parallel</a></div><div class="post_share"><div class="social-share" data-image="/image/parallel.png" data-sites="twitter,wechat,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.3" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js?v=1.1.3" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c2e6ce0c/" title="Pthreads"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/parallel.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Pthreads</div><div class="content">进程和线程、Pthreads 程序结构、竞争条件、路障实现、读写锁、缓存</div></div></a></div><div class="next-post pull-right"><a href="/posts/d79b6007/" title="并行概念"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/parallel.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并行概念</div><div class="content">并行概念辨析、并行硬件（系统、网络、模式、架构）、并行软件（SPMD、I/O、Foster）、并行性能（加速比、效率、可扩展性、阿姆达尔定律、计算和开销）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d79b6007/" title="并行概念"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/parallel.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-06</div><div class="title">并行概念</div><div class="info">并行概念辨析、并行硬件（系统、网络、模式、架构）、并行软件（SPMD、I/O、Foster）、并行性能（加速比、效率、可扩展性、阿姆达尔定律、计算和开销）</div></div></a></div><div><a href="/posts/c2e6ce0c/" title="Pthreads"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/parallel.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-06</div><div class="title">Pthreads</div><div class="info">进程和线程、Pthreads 程序结构、竞争条件、路障实现、读写锁、缓存</div></div></a></div><div><a href="/posts/d6137872/" title="OpenMP"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/parallel.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-06</div><div class="title">OpenMP</div><div class="info">OpenMP 结构、编译指令、子句、迭代并行、调度方式、互斥机制、消息队列</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MPI-%E7%A8%8B%E5%BA%8F"><span class="toc-text">1. MPI 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A1%86%E6%9E%B6"><span class="toc-text">1.2 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%80%9A%E4%BF%A1%E5%AD%90"><span class="toc-text">1.3 通信子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%82%B9%E5%AF%B9%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="toc-text">2. 点对点通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%89%B9%E7%82%B9"><span class="toc-text">2.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-MPI-Send"><span class="toc-text">2.2 MPI_Send</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-MPI-Recv"><span class="toc-text">2.3 MPI_Recv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-MPI-Sendrecv"><span class="toc-text">2.4 MPI_Sendrecv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BD%92%E7%BA%A6"><span class="toc-text">2.5 归约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1"><span class="toc-text">3. 集合通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%89%B9%E7%82%B9"><span class="toc-text">3.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-MPI-Bcast"><span class="toc-text">3.2 MPI_Bcast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-MPI-Scatter"><span class="toc-text">3.3 MPI_Scatter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-MPI-Gather"><span class="toc-text">3.4 MPI_Gather</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-MPI-Allgather"><span class="toc-text">3.5 MPI_Allgather</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-MPI-Reduce"><span class="toc-text">3.6 MPI_Reduce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 派生数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-MPI-Type-contiguous"><span class="toc-text">4.2 MPI_Type_contiguous</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-MPI-Type-create-struct"><span class="toc-text">4.3 MPI_Type_create_struct</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">5. 性能评估</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AE%A1%E6%97%B6"><span class="toc-text">5.1 计时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1-vs-%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-text">5.2 问题规模 vs 进程数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%9E%E8%B7%B5"><span class="toc-text">6. 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A2%AF%E5%BD%A2%E7%A7%AF%E5%88%86%E6%B3%95"><span class="toc-text">6.1 梯形积分法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC"><span class="toc-text">6.1.1 公式推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E4%B8%B2%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="toc-text">6.1.2 串行算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="toc-text">6.1.3 并行算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%B9%B6%E8%A1%8C%E5%A5%87%E5%81%B6%E6%8D%A2%E4%BD%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">6.2 并行奇偶换位排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E5%8E%9F%E7%90%86"><span class="toc-text">6.2.1 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E4%B8%B2%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="toc-text">6.2.2 串行算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="toc-text">6.2.3 并行算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E4%B9%98%E6%B3%95"><span class="toc-text">6.3 矩阵向量乘法</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Dasi</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa-solid fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa-solid fa-arrow-rotate-right"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa-solid fa-arrow-right"></i></a><a class="rightMenu-item" id="menu-radompage" href="javascript:window.location.href = window.location.origin;"><i class="fa-solid fa-house"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa-solid fa-copy"></i><span>复制</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa-solid fa-circle-half-stroke"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa-solid fa-book"></i><span>阅读模式</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa-solid fa-arrow-up"></i><span>置顶</span></a><a class="rightMenu-item" href="javascript:rmf.copyPageUrl();"><i class="fa-solid fa-link"></i><span>复制链接</span></a></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.33"></script><script src="/pluginsSrc/instant.page/instantpage.js?v=5.2.0" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js?v=17.8.8"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js?v=4.0.7").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css?v=0.16.9"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js?v=0.16.9"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.dasi.net.cn/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"==typeof twikoo?setTimeout(t,0):getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.31").then(t)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/rightmenu.js?1"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/rightside.js?1"></script><script src="/js/sitetitle.js?1"></script><script id="click-show-text" src="/pluginsSrc/butterfly-extsrc/dist/click-show-text.min.js?v=1.1.3" data-mobile="false" data-text="d,a,s,i" data-fontsize="20px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/7bb01bb2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/algorithm.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" href="posts/7bb01bb2/" alt="">动态规划</a><div class="blog-slider__text">介绍了动态规划的原理，并用4个典例进行了详细分析，总结过后完成经典DP问题</div><a class="blog-slider__button" href="posts/7bb01bb2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/46ae7d29/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/ai.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-28</span><a class="blog-slider__title" href="posts/46ae7d29/" alt="">α-β剪枝</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/46ae7d29/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/f11dbe61/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/git.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-09-13</span><a class="blog-slider__title" href="posts/f11dbe61/" alt="">Git基本操作</a><div class="blog-slider__text">介绍git的基本操作以及对git指令的理解</div><a class="blog-slider__button" href="posts/f11dbe61/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/57fa915c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/algorithm.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-14</span><a class="blog-slider__title" href="posts/57fa915c/" alt="">排序</a><div class="blog-slider__text">想一个默认描述好难的！</div><a class="blog-slider__button" href="posts/57fa915c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/55f40959/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/ai.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-21</span><a class="blog-slider__title" href="posts/55f40959/" alt="">谓词逻辑的归结反演</a><div class="blog-slider__text">如何利用python实现谓词逻辑的归结反演，详细分析了每个函数</div><a class="blog-slider__button" href="posts/55f40959/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/bbea855c/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/network.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-22</span><a class="blog-slider__title" href="posts/bbea855c/" alt="">运输层</a><div class="blog-slider__text">多路复用、多路分解、UDP和TCP、可靠数据传输原理、流水线模式和拥塞控制算法</div><a class="blog-slider__button" href="posts/bbea855c/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>